@node The First Application
@chapter The First Application
@cindex building an application
@cindex writing an application

@menu
* How CLIM applications produce output::
* Panes and Gadgets::
* Defining Application Frames::
* A First Attempt::
* Executing the Application::
* Adding Functionality::
* An application displaying a data structure::
* Incremental redisplay::
@end menu

@node How CLIM applications produce output
@section How CLIM applications produce output

CLIM stream panes use output recording.  This means that such a pane
maintains a display list, consisting of a sequence of output records,
ordered chronologically, from the first output record to be drawn to
the last.  

This display list is used to fill in damaged areas of the pane, for
instance as a result of the pane being partially or totally covered by
other panes, and then having some or all of its area again becoming
visible.  The output records of the display list that have some parts
in common with the exposed area are partially or totally replayed (in
chronological order) to redraw the contents of the area.

An application can have a pane establish this display list in several
fundamentally different ways.

Very simple applications have no internal data structure to keep track
of application objects, and simply produce output to the pane from
time to time as a result of running commands, occasionally perhaps
erasing the pane and starting over.  Such applications typically use
text or graphics output as a result of running commands.  CLIM
maintains the display list for the pane, and adds to the end of it,
each time also producing the pixels that result from drawing the new
output record.  If the pane uses scrolling (which it typically does),
then CLIM must determine the extent of the pane so as to update the
scroll bar after each new output.  

More complicated applications use a display function.  Before the
display function is run, the existing display list is typically
deleted, so that the purpose of the display function becomes to
establish an entirely new display list.  The display function might
for instance produce some kind of form to be filled in, and
application commands can use text or graphics operations to fill in
the form.  A game of tic-tac-toe could work this way, where the
display function draws the board and commands draw shapes into the
squares.  

Even more complicated applications might have some internal data
structure that has a direct mapping to output, and commands simply
modify this internal data structure.  In this case, the display
function is run after each time around the command loop, because a
command can have modified the internal data structure in some
arbitrary ways.  Some such applications might simply want to delete
the existing display list and produce a new one each time (to minimize
flicker, double buffering could be used).  This is a very simple way
of structuring an application, and entirely acceptable in many cases.
Consider, for instance, a board game where pieces can be moved (as
opposed to just added).  A very simple way of structuring such an
application is to have an internal representation of the board, and to
make the display function traverse this data structure and produce the
complete output each time in the command loop.  

Some applications have very large internal data structures to be
displayed, and it would cause a serious performance problem if the
display list had to be computer from scratch each time around the
command loop.  To solve this problem, CLIM contains a feature called
incremental redisplay.  It allows many of the output records to be
kept from one iteration of the command loop to the next.  This can be
done in two different ways.  The simplest way is for the application
to keep the simple structure which consists of traversing the entire
data structure each time, but at various points indicate to CLIM that
the output has not changed since last time, so as to avoid actually
invoking the application code for computing it.  This is accomplished
by the use of @t{updating-output}.  The advantage of
@t{updating-output} is that the application logic remains
straightforward, and it is up to CLIM to do the hard work of recycling
output records.  The disadvantage is that for some very demanding
applications, this method might not be fast enough.

The other way is more complicated and requires the programmer to
structure the application differently.  Essentially, the application
has to keep track of the output records in the display list, and
inform CLIM about modifications to it.  The main disadvantage of this
method is that the programmer must now write the application to keep
track of the output records itself, as opposed to leaving it to CLIM. 

@node Panes and Gadgets
@section Panes and Gadgets

A CLIM application is made up of a hierarchy of @gloss{panes} and
@gloss{gadgets} (gadgets are special kinds of panes).  These elements
correspond to what other toolkits call @emph{widgets}.  Frequently used
CLIM gadgets are @gadget{button}s, @gadget{slider}s, etc, and typical
panes are the layout panes such as @pane{hbox}, @pane{vbox},
@pane{hrack}, etc.
@cindex pane
@cindex gadget

@node Defining Application Frames
@section Defining Application Frames

Each CLIM application is defined by an @gloss{application frame}.  An
application frame is an instance of the class @class{application-frame}.
As a CLIM user, you typically define a class that inherits from the
class @class{application-frame}, and that contains additional slots
needed by your application.  It is considered good style to keep all
your application-specific data in slots in the application frame (rather
than, say, in global variables), and to define your application-specific
application frame in its own package.
@cindex application frame

The usual way to define an application frame is to use the macro
@fmacro{define-application-frame}.  This macro works much like
@fmacro{defclass}, but also allows you to specify the hierarchy of
@gloss{panes} and @gloss{gadgets} to use.

@node A First Attempt
@section A First Attempt

Let us define a very primitive CLIM application.  For that, let us put
the following code in a file:

@lisp
@include ex1.lisp
@end lisp

As we can see in this example, we have put our application in a separate
package, here a package named @t{APP}.  While not required, putting the
application in its own package is good practice.

The package for the application uses two packages: @package{CLIM} and
@package{CLIM-LISP}.  The @package{CLIM} package is the one that
contains all the symbols needed for using CLIM.  The @package{CLIM-LISP}
package replaces the @package{COMMON-LISP} package for CLIM
applications.  It is essentially the same as the @package{COMMON-LISP}
package as far as the user is concerned.

In our example, we export the symbol that corresponds to the main
function to start our application, here called @t{APP-MAIN}.

The most important part of the code in our example is the definition of
the application-frame.  In our example, we have defined an application
frame called @t{superapp}, which becomes a CLOS class that automatically
inherits from some standard CLIM application frame class.

The second argument to @fmacro{define-application-frame} is a list of
additional superclasses from which you want your application frame to
inherit.  In our example, this list is empty, which means that our
application frame only inherits from the standard CLIM application
frame.

The third argument to @fmacro{define-application-frame} is a list of
CLOS slots to be added to any instance of this kind of application
frame.  These slots are typically used for holding all
application-specific data.  The current instance of the application
frame will always be the value of the special variable
@t{*application-frame*},
@vindex *application-frame*
so that the values of these slots can be accessed.  In our example, we
do not initially have any further slots.

The rest of the definition of an application frame contains additional
elements that CLIM will allow the user to define.  In our example, we
have two additional (mandatory) elements: @t{:panes} and @t{:layouts}.

The @t{:panes} element defines a collection of CLIM panes that each
instance of your application may have.  Each pane has a name, a type,
and perhaps some options that are used to instantiate that particular
type of pane.  Here, we have a pane called @t{int} of type
@t{:interactor} with a height of 400 units and a width of 600 units.  In
McCLIM, the units are initially physical units (number of pixels) of the
native windowing system.

The @t{:layouts} element defines one or more ways of organizing the
panes in a hierarchy.  Each layout has a name and a description of a
hierarchy.  In our example, only one layout, named @t{default}, is
defined.  The layout called @t{default} is the one that is used by CLIM
at startup.  In our example, the corresponding hierarchy is trivial,
since it contains only the one element @t{int}, which is the name of our
only pane.

@node Executing the Application
@section Executing the Application

In order to run a CLIM application, you must have a Lisp system that
contains McCLIM.  If you use CMUCL or SBCL, you either need a @t{core}
file that already has McCLIM in it, or else, you have to load the McCLIM
compiled files that make up the McCLIM distribution.  The fist solution
is recommended so as to avoid having to load the McCLIM files each time
you start your CLIM application.

To execute the application, load the file containing your code (possibly
after compiling it) into your running Lisp system.  Then start the
application.  Our example can be started by typing @t{(app:app-main)}.

@node Adding Functionality
@section Adding Functionality

In a serious application, you would probably want some area where your
application objects are to be displayed.  In CLIM, such an area is
called an @emph{application pane}, and would be an instance (direct or
indirect) of the CLIM class @t{application-pane}.  In fact, instances of
this class are in reality also @emph{streams} which can be used in calls
both to ordinary input and output functions such as @t{format} and
@t{read} and to CLIM-specific functions such as @t{draw-line}.

In this example we have such an application pane, the name of which is
@t{app}.  As you can see, we have defined it with an option
@t{:display-time nil}.  The default value for this option for an
application pane is @t{:command-loop}, which means that the pane is
cleared after each iteration in the command loop, and then redisplayed
using a client-supplied @emph{display function}.  The default display
function does nothing, and we have not supplied any, so if we had
omitted the @t{:display-time nil} option, the @t{parity} command would
have written to the pane.  Then, at the end of the command loop, the
pane would have been cleared, and nothing else would have been
displayed.  The net result is that we would have seen no visible output.
With the option @t{:display-time nil}, the pane is never cleared, and
output is accumulated every time we execute the @t{parity} command.

For this example, let us also add a few @emph{commands}.
@cindex command
Such commands are defined by the use of a macro called
@fmacro{@t{define-}@i{name}@t{-command}}, where @i{name} is the name of
the application, in our case @t{superapp}. This macro is automatically
defined by @t{define-application-frame}.

Let us also add a pane that automatically provides documentation for
different actions on the pointer device.

Here is our improved example:

@lisp
@include ex2.lisp
@end lisp

If you execute this example, you will find that you now have three
different panes, the application pane, the interactor pane and the
pointer documentation pane.  In the pointer documentation pane, you will
see the text @t{R possibilities} which indicates that if you click the
right mouse button, you will automatically see a popup menu that lets
you choose a command.  In our case, you will have the default commands
that are automatically proposed by McCLIM plus the commands that you
defined yourself, in this case @t{quit} and @t{parity}.

@ref{fig:figex2} shows what ought to be visible on the screen.

@float Figure,fig:figex2
@image{ex2,5in,5in,View of the improved example}
@end float

Notice that commands, in order to be available from the command line,
must have an option of @t{:name t}.  The reason is that some commands
will be available only from menus or by some other mechanism.

You may notice that if the output of the application is hidden (say by
the window of some other application) and then re-exposed, the output
reappears normally, without any intervention necessary on the part of
the programmer.  This effect is accomplished by a CLIM mechanism called
@emph{output recording}.
@cindex output recording
Essentially, every piece of output is not only displayed in the pane,
but also captured in an @emph{output record} associated with the pane.
When a pane is re-exposed, its output records are consulted and if any
of them overlap the re-exposed region, they are redisplayed.  In fact,
some others may be redisplayed as well, because CLIM guarantees that the
effect will be the same as when the initial output was created.  It does
that by making sure that the order between (partially) overlapping
output records is respected.

Not all panes support output recording, but certainly application panes
do, so it is good to use some subclass of @t{application-pane} to
display application-specific object, because output recording is then
automatic.

@node An application displaying a data structure
@section An application displaying a data structure

Many applications use a central data structure that is to be on display
at all times, and that is modified by the commands of the application.
CLIM allows for a very easy way to write such an application.  The main
idea is to store the data structure in slots of the application frame,
and to use a @emph{display function}
@cindex display function
that after each iteration of the command loop displays the entire data
structure to the application pane.

Here is a variation of the previous application that shows this
possibility:

@lisp
@include ex2b.lisp
@end lisp

Here, we have added a slot that is called @t{current-number} to the
application frame.  It is initialized to @cl{NIL} and it has an accessor
function that allow us to query and to modify the value.

Observe that in this example, we no longer have the option
@t{:display-time nil} set in the application pane.  By default, then,
the @t{:display-time} is @t{:command-loop} which means that the pane is
erased after each iteration of the command loop.  Also observe the
option @t{:display-function} which takes a symbol that names a function
to be called to display the pane after it has been cleared.  In this
case, the name is @t{display-app}, the name of the function defined
immediately after the application frame.

Instead of immediately displaying information about its argument, the
command @t{com-parity} instead modifies the new slot of the application
frame.  Think of this function as being more general, for instance a
command to add a new object to a set of graphical objects in a figure
drawing program, or as a command to add a new name to an address book.
Notice how this function accesses the current application frame by means
of the special variable @t{*application-frame*}.

A display function is called with the frame and the pane as arguments.
It is good style to use the pane as the stream in calls to functions
that will result in output.  This makes it possible for the same
function to be used by several different frames, should that be called
for.  In our simple example, the display function only displays the
value of a single number (or @cl{NIL}), but you could think of this as
displaying all the objects that have been drawn in some figure drawing
program or displaying all the entries in an address book.

@node Incremental redisplay
@section Incremental redisplay

While the example in the previous section is a very simple way of
structuring an application (let commands arbitrarily modify the data
structure, and simply erase the pane and redisplay the structure after
each iteration of the command loop), the visual result is not so great
when many objects are to be displayed.  There is most often a noticeable
flicker between the moment when the pane is cleared and the objects are
drawn.  Sometimes this is inevitable (as when nearly all objects
change), but most of the time, only an incremental modification has been
made, and most of the objects are still in the same place as before.

In simple toolkits, the application programmer would have to figure out
what has changed since the previous display, and only display the
differences.  CLIM offers a mechanism called @emph{incremental
redisplay}
@cindex incremental redisplay
that automates a large part of this task.  As we mentioned earlier, CLIM
captures output in the form of @emph{output records}.  The same
mechanism is used to obtain incremental redisplay.

To use incremental redisplay, Client code remains structured in the
simple way that was mention above: after each iteration of the command
loop, the display function output the entire data structure as usual,
except that it helps the incremental redisplay mechanism by telling CLIM
which piece of output corresponds to which piece of output during the
previous iteration of the command loop.  It does this by giving some
kind of @emph{unique identity} to some piece of output, and some means
of indicating whether the contents of this output is @emph{the same} as
it was last time.  With this information, the CLIM incremental redisplay
mechanism can figure out whether some output is new, has disappeared, or
has been moved, compared to the previous iteration of the command loop.
As with re-exposure, CLIM guarantees that the result is identical to
that which would have been obtained, had all the output records been
output in order to a blank pane.

The next example illustrates this idea.  It is a simple application that
displays a fixed number (here 20) of lines, each line being a number.
Here is the code:

@lisp
@include ex2c.lisp
@end lisp

We store the numbers in a slot called @t{numbers} of the application
frame.  However, we store each number in its own list.  This is a simple
way to provide a unique identity for each number.  We could not use the
number itself, because two numbers could be the same and the identities
would not be unique.  Instead, we use the cons cell that store the
number as the unique identity.  By using @t{:id-test #'eq} we inform
CLIM that it can figure out whether an output record is the same as one
that was issued previous time by using the function @t{eq} to compare
them.  But there is a second test that has to be verified, namely
whether an output record that was issued last time has to be redisplayed
or not.  That is the purpose of the cache-value.  Here we use the number
itself as the cache value and @t{eql} as the test to determine whether
the output is going to be the same as last time.

For convenience, we display a @t{*} at the beginning of the current
line, and we provide two commands @t{next} and @t{previous} to navigate
between the lines.

Notice that in the declaration of the pane in the application frame, we
have given the option @t{:incremental-redisplay t}.  This informs CLIM
not to clear the pane after each command-loop iteration, but to keep the
output records around and compare them to the new ones that are produced
during the new iteration.
