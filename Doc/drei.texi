@c This is part of the McCLIM manual and included during the building
@c process.
@node Drei
@chapter Drei
@cindex drei
@cindex input-editor
@cindex text-editor
@cindex text-field

Drei - an acronym for @i{Drei Replaces EINE's Inheritor} - is one of the
editor substrates provided by McCLIM. It is currently disabled by
default (instead, a somewhat less sophisticated editor substrate,
Goatee, is used), but it can be activated by evaluating @code{(setf
clim-internals::*use-goatee* nil)}.

@menu
* Drei Concepts::               The core Drei concepts and design philosophy.
* External API::                The classes, functions and macros that make
                                up the core of Drei
* Standard Drei Variants::      How to use the predefined Drei variants.
* Protocols::                   Description of protocols used by Drei.
* Defining Drei Commands::      Information about defining commands for Drei
@end menu

@node Drei Concepts
@section Drei Concepts

The reason for many of Drei's design decisions, and the complexity of
some of the code, is due to the flexibility that Drei is meant to
expose. Drei has to work as, at least, an input-editor, a text editor
gadget and a simple pane. These three different uses have widely
different semantics for reading input and performing redisplay - from
passively being fed gestures in the input editor, to having to event
handling and redisplay timing manually in the gadget
version. Furthermore, Drei is extensible software, so we wished to make
the differences between these three modus operandorum transparent to the
extender (as much as possible at least, unfortunately the Law of Leaky
Abstractions prevents us from reaching perfection). These two demands
require the core Drei protocols, especially those pertaining to
redisplay, gesture handling and accepting input from the user, to be
customizable by the different specialized Drei classes.

We call a specific instance of the Drei editor substrate a @i{Drei
instance}. A @i{Drei variant} is a specific subclass of @class{drei}
that implements a specific kind of editor, such as an input-editor or a
gadget. A given Drei instance has a single buffer associated with it,
but this buffer need not be unique to the Drei instance, and may be
changed at any time. The Drei instance has two marks into the buffer,
called the @i{top} and @i{bottom} mark. These marks delimit the visible
region of the buffer - for some Drei variants, this is always the entire
buffer, while others may only have a smaller visible region. Note that
not all of the visible region necessarily is on display on the screen
(parts, or all, of it may be hidden due to scrolling, for example), but
nothing outside the visible region is on display, though remember that
the same buffer may be used in several Drei instances, and that each of
these instances may have their own idea about what the visible region
is. The Drei instance also maintains marks for the current @i{point} and
@i{mark}. This means that different Drei instances sharing the same
buffer may have different points and marks. Every Drei instance also has
a @i{kill ring} object which contains object sequences that have been
killed from the buffer, and can be yanked back in at the users
behest. These are generally not shared.

Every Drei instance is associated with an editor pane - this must be a
CLIM stream pane that is used for redisplay (@pxref{Redisplay
Protocol}). This is not necessarily the same object as the Drei instance
itself, but it can be.

For each Drei instance, Drei attempts to simulate an application
top-level loop with something called a @i{pseudo command loop}, and
binds a number of special variables appropriately. This is to make
command writing more convenient and similar across all Drei variants,
but it also means that any program that uses one of the low-level Drei
variants that do not to this, such as @class{drei-pane}, need to bind
these special variables themselves, or Drei commands are likely to
malfunction.

@menu
* Special Variables::           
@end menu

@node Special Variables
@subsection Special Variables

Drei commands are meant to work by using the values of a number of
special variables bound by Drei during its pseudo command loop.  Here is
a list of them:

@defvar *current-window*
@vindex *current-window*
Somewhat counter-intuitively, the Drei instance. Not necessarily the
same as the editor pane.
@end defvar
@defvar *current-buffer*
@vindex *current-buffer*
The buffer of the Drei instance the command is being executed for.
@end defvar
@defvar *current-mark*
@vindex *current-mark*
The mark of the Drei instance.
@end defvar
@defvar *current-point*
@vindex *current-point*
The point of the Drei instance.
@end defvar
@defvar *current-syntax*
@vindex *current-syntax*
The syntax of @cl{*current-buffer*}.
@end defvar
@defvar *kill-ring*
@vindex *kill-ring*
The kill-ring object of the Drei instance.
@end defvar
@defvar *minibuffer*
@vindex *minibuffer*
The minibuffer of the Drei instance, which is where commands should
print information and other interesting things (using
@cl{display-message} or @cl{with-minibuffer-stream}). This may be
@cl{NIL} if no minibuffer is associated with the Drei instance.
@end defvar
@defvar *previous-command*
@vindex *previous-command*
The previous CLIM command that was executed by the Drei instance.
@end defvar

@node External API
@section External API

@deftp {Class} drei

The abstract Drei class that maintains standard Drei editor state. It
should not be directly instantiated, a subclass implementing specific
behavior should be used instead.
@end deftp

@deftp {@class{drei} Initarg} {:editable-p}
Whether or not the Drei instance will be editable. If @cl{NIL}, the
buffer will be set to read-only (this also affects programmatic
access). The default is @cl{T}.
@end deftp

@deftp {@class{drei} Initarg} {:single-line}
If @cl{T}, the buffer created for the Drei instance will be single line,
and a condition of type @class{buffer-single-line} will be signalled if
an attempt is made to insert a newline character.
@end deftp

@deffn {Generic Function} {view} drei
@deffnx {Generic Function} {(setf view)} view drei
@findex view
The CLIM view that will be used whenever @var{drei} is being
displayed. During redisplay, the @cl{stream-default-view} of the editor
pane will be temporarily bound to this value.
@end deffn

@deffn {Generic Function} {kill-ring} drei
@deffnx {Generic Function} {(setf kill-ring)} kill-ring drei
@findex view

The kill ring object used by @var{drei}.
@end deffn

@deffn {Generic Function} {previous-command} drei
@deffnx {Generic Function} {(setf previous-command)} command drei
@findex previous-command

The previous command executed by @var{drei}.
@end deffn

@deffn {Generic Function} {minibuffer} drei
@deffnx {Generic Function} {(setf minibuffer)} pane drei
@findex minibuffer

The minibuffer associated with @var{drei}. This may be @cl{NIL}.
@end deffn

@defmac {handling-drei-conditions} &body body
@findex handling-drei-conditions

Evaluate `body' while handling Drei user notification signals. The
handling consists of displaying their meaning to the user in the
minibuffer. This is the macro that ensures conditions such as
@cl{motion-before-end} does not land the user in the debugger.
@end defmac

@defmac {with-bound-drei-special-variables} {((drei-instance &key current-buffer current-window current-mark current-point current-syntax kill-ring minibuffer command-parser partial-command-parser previous-command prompt) &body body)}

Evaluate @var{body} with Drei special variables bound to their proper
values, taken from @var{drei-instance}. The keyword arguments can be
used to provide forms that will be used to obtain values for the
respective special variables instead of the default. This macro binds
all of the special variables listed in @ref{Special Variables}, but also
some CLIM special variables needed for ESA-style command parsing.
@end defmac

@defmac {performing-drei-operations} {((drei &rest args &key with-undo (update-syntax t) (redisplay t)) &body body)}

Provide various Drei convenience services around the evaluation of
@var{body}. This macro provides a convenient way to perform some
operations on a Drei, and make sure that they are properly reflected in
the undo tree, that the Drei is redisplayed, the syntax updated,
etc. Exactly what is done can be controlled via the keyword
arguments. Note that if @var{:with-undo'} is false (the default), the
@emph{entire} undo history will be cleared after @var{body} has been
evaluated. This macro expands into a call to
@cl{invoke-performing-drei-operations}.
@end defmac

@deffn {Generic Function} {invoke-performing-drei-operations} {(drei continuation &key with-undo update-syntax redisplay)}

Implement the behavior of @cl{performing-drei-operations}.
@end deffn

@deffn {Generic Function} {execute-drei-command} drei command

Execute @var{command} for @var{drei}. This is the standard function for
executing Drei commands - it will take care of reporting to the user if
a condition is signalled, updating the syntax, setting the
@cl{previous-command} of @var{drei} and recording the operations
performed by @var{command} for undo.
@end deffn

@defmac {accepting-from-user} ((drei) &body body)
Modidfy @var{drei} and the environment so that calls to @cl{accept} can
be done to arbitrary streams from within @var{body}. Or, at least, make
sure the Drei instance will not be a problem. When Drei calls a command,
it will be wrapped in this macro, so it should be safe to use
@cl{accept} within Drei commands. This macro expands into a call to
@cl{invoke-accepting-from-user}
@end defmac

@deffn {Generic Function} {invoke-accepting-from-user} {(drei continuation)}

Implement the behavior of @cl{performing-drei-operations}.
@end deffn

@node Standard Drei Variants
@section Standard Drei Variants

Because the standard @class{drei} class doesn't implement
immediately-usable editor behavior, three subclasses have been defined
to provide a concrete implementaton of the editor substrate. These are
the input-editor-oriented Drei variant, the pane-oriented Drei variant
and the gadget-oriented Drei variant.

@node Protocols
@section Protocols
@cindex Drei protocols
@cindex text-editor protocols
@cindex text-editor API
@cindex Drei API

Much of Drei's functionality is based on generic function
protocols. This section lists some of them.

@menu
* Buffer Protocol::             
* Buffer Modification Protocol::  
* DREI-BASE Package::           
* Syntax Protocol::             
* Unit Protocol::               
* Redisplay Protocol::          
* Undo Protocol::               
* Kill Ring Protocol::          
@end menu

@node Buffer Protocol
@subsection Buffer Protocol

The Drei buffer is what holds textual and other objects to be
edited and displayed.  Conceptually, the buffer is a potentially
large sequence of objects, most of which are expected to be
characters (the full Unicode character set is supported).  However,
Drei buffers can contain any Common Lisp objects, as long as the
syntax module knows how to render them.

The Drei  buffer implementation differs from that of a vector,
because it allows for very efficient editing operations, such as
inserting and removing objects at arbitrary offsets.

In addition, the Drei buffer protocols defines that concept of a
mark.

@menu
* General Buffer Protocol Parts::  
* Operations Related To The Offset Of Marks::  
* Inserting And Deleting Objects::  
* Getting Objects Out Of The Buffer::  
* Implementation Hints::        
@end menu

@node General Buffer Protocol Parts
@subsubsection General Buffer Protocol Parts

@deftp {Protocol Class} buffer

The base class for all buffers.  A buffer conceptually contains a
large array of arbitrary objects.  Lines of objects are separated by
newline characters.  The last object of the buffer is not
necessarily a newline character.
@end deftp

@deftp {Class} standard-buffer

The standard instantiable class for buffers.  A subclass of buffer.
@end deftp

@deftp {Protocol Class} mark

The base class for all marks.
@end deftp

@deftp {@class{buffer} Initarg} :buffer

The :buffer initarg is mandatory because no mark can exist without a
buffer.
@end deftp

@deftp {@class{buffer} Initarg} :offset

If an :offset initarg is given that is less than zero or greater than
the size of the buffer, a no-such-offset condition is signaled. When the
:offset initarg is not given, it defaults to zero.
@end deftp

@deftp {Protocol Class} left-sticky-mark

A subclass of mark.  A mark of this type will "stick" to the object
to the left of it, i.e. when an object is inserted at this mark, the
mark will be positioned to the left of the object.
@end deftp

@deftp {Protocol Class} right-sticky-mark

A subclass of mark.  A mark of this type will "stick" to the object
to the right of it, i.e. when an object is inserted at this mark, the
mark will be positioned to the right of the object.
@end deftp

@deffn {Generic Function} {clone-mark} mark &optional stick-to

Clone a mark.  By default (when stick-to is NIL) the same type of mark
is returned.  Otherwise stick-to is either :left, indicating that a
left-sticky-mark should be created, or :right indicating that a
right-sticky-mark should be created.
@end deffn

@deffn {Generic Function} {buffer} mark

Return the buffer that the mark is positioned in.
@end deffn

@deftp {Error Condition} no-such-offset

This condition is signaled whenever an attempt is made to access an
object that is before the beginning or after the end of the buffer.
@end deftp

@deftp {Error Condition} offset-before-beginning

This condition is signaled whenever an attempt is made to access
buffer contents that is before the beginning of the buffer.
This condition is a subclass of no-such-offset
@end deftp

@deftp {Error Condition} offset-after-end

This condition is signaled whenever an attempt is made to access
buffer contents that is after the end of the buffer.
This condition is a subclass of no-such-offset
@end deftp

@deftp {Error Condition} invalid-motion

This condition is signaled whenever an attempt is made to move a mark
before the beginning or after the end of the buffer.
@end deftp

@deftp {Error Condition} motion-before-beginning

This condition is signaled whenever an attempt is made to move a mark
before the beginning of the buffer.
This condition is a subclass of invalid-motion.
@end deftp

@deftp {Error Condition} motion-after-end

This condition is signaled whenever an attempt is made to move a mark
after the end of the buffer.
This condition is a subclass of invalid-motion.
@end deftp

@deffn {Generic Function} {size} buffer

Return the number of objects in the buffer.
@end deffn

@deffn {Generic Function} {number-of-lines} buffer

Return the number of lines of the buffer, or really the number of
newline characters.
@end deffn

@node Operations Related To The Offset Of Marks
@subsubsection Operations Related To The Offset Of Marks

@deffn {Generic Function} {offset} mark

Return the offset of the mark into the buffer.
@end deffn

@deffn {Generic Function} {(setf offset)} offset mark

Set the offset of the mark into the buffer.  A motion-before-beginning
condition is signaled if the offset is less than zero. A
motion-after-end condition is signaled if the offset is greater than
the size of the buffer.
@end deffn

@deffn {Generic Function} {forward-object} mark &optional (count 1)

Move the mark forward the number of positions indicated by count.
This function could be implemented by an incf on the offset of the
mark, but many buffer implementations can implement this function much
more efficiently in a different way.  A motion-before-beginning
condition is signaled if the resulting offset of the mark is less than
zero. A motion-after-end condition is signaled if the resulting offset
of the mark is greater than the size of the buffer.
@end deffn

@deffn {Generic Function} {backward-object} mark &optional (count 1)

Move the mark backward the number of positions indicated by count.
This function could be implemented by a decf on the offset of the
mark, but many buffer implementations can implement this function much
more efficiently in a different way. A motion-before-beginning
condition is signaled if the resulting offset of the mark is less than
zero. A motion-after-end condition is signaled if the resulting offset
of the mark is greater than the size of the buffer.
@end deffn

@deffn {Generic Function} {mark<} mark1 mark2

Return t if the offset of mark1 is strictly less than that of mark2.
An error is signaled if the two marks are not positioned in the same
buffer.  It is acceptable to pass an offset in place of one of the
marks.
@end deffn

@deffn {Generic Function} {mark<=} mark1 mark2

Return t if the offset of mark1 is less than or equal to that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark>} mark1 mark2

Return t if the offset of mark1 is strictly greater than that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark>=} mark1 mark2

Return t if the offset of mark1 is greater than or equal to that of
mark2.  An error is signaled if the two marks are not positioned in
the same buffer.  It is acceptable to pass an offset in place of one
of the marks.
@end deffn

@deffn {Generic Function} {mark=} mark1 mark2

Return t if the offset of mark1 is equal to that of mark2.  An error
is signaled if the two marks are not positioned in the same buffer.
It is acceptable to pass an offset in place of one of the marks.
@end deffn

@deffn {Generic Function} {beginning-of-buffer} mark

Move the mark to the beginning of the buffer.  This is equivalent to
(setf (offset mark) 0)
@end deffn

@deffn {Generic Function} {end-of-buffer} mark

Move the mark to the end of the buffer.
@end deffn

@deffn {Generic Function} {beginning-of-buffer-p} mark

Return t if the mark is at the beginning of the buffer, nil
otherwise.
@end deffn

@deffn {Generic Function} {end-of-buffer-p} mark

Return t if the mark is at the end of the buffer, nil otherwise.
@end deffn

@deffn {Generic Function} {beginning-of-line} mark

Move the mark to the beginning of the line.  The mark will be
positioned either immediately after the closest preceding newline
character, or at the beginning of the buffer if no preceding newline
character exists.
@end deffn

@deffn {Generic Function} {end-of-line} mark

Move the mark to the end of the line. The mark will be positioned
either immediately before the closest following newline character, or
at the end of the buffer if no following newline character exists.
@end deffn

@deffn {Generic Function} {beginning-of-line-p} mark

Return t if the mark is at the beginning of the line (i.e., if the
character preceding the mark is a newline character or if the mark is
at the beginning of the buffer), nil otherwise.
@end deffn

@deffn {Generic Function} {end-of-line-p} mark

Return t if the mark is at the end of the line (i.e., if the character
following the mark is a newline character, or if the mark is at the
end of the buffer), nil otherwise.
@end deffn

@deffn {Generic Function} {buffer-line-number} buffer offset

Return the line number of the line at offset.  Lines are numbered from
zero.
@end deffn

@deffn {Generic Function} {buffer-column-number} buffer offset

Return the column number of the line at offset. It is the number of
objects between it and the preceding newline, or between it and the
beginning of the buffer if offset is on the first line of the buffer.
@end deffn

@deffn {Generic Function} {line-number} mark

Return the line number of the mark.  Lines are numbered from zero.
@end deffn

@deffn {Generic Function} {column-number} mark

Return the column number of the mark. The column number of a mark is
the number of objects between it and the preceding newline, or
between it and the beginning of the buffer if the mark is on the
first line of the buffer.
@end deffn

@node Inserting And Deleting Objects
@subsubsection Inserting And Deleting Objects

@deffn {Generic Function} {insert-buffer-object} buffer offset object

Insert the object at the offset in the buffer.  Any left-sticky marks
that are placed at the offset will remain positioned before the
inserted object.  Any right-sticky marks that are placed at the
offset will be positioned after the inserted object.
@end deffn

@deffn {Generic Function} {insert-buffer-sequence} buffer offset sequence

Like calling insert-buffer-object on each of the objects in the
sequence.
@end deffn

@deffn {Generic Function} {insert-object} mark object

Insert the object at the mark.  This function simply calls
insert-buffer-object with the buffer and the position of the mark.
@end deffn

@deffn {Generic Function} {insert-sequence} mark sequence

Insert the objects in the sequence at the mark. This function simply
calls insert-buffer-sequence with the buffer and the position of the
mark.
@end deffn

@deffn {Generic Function} {delete-buffer-range} buffer offset n

Delete n objects from the buffer starting at the offset.  If offset is
negative, a offset-before-beginning condition is signaled.  If
offset+n is greater than the size of the buffer, a offset-after-end
condition is signaled.
@end deffn

@deffn {Generic Function} {delete-range} mark &optional (n 1)

Delete n objects after (if n > 0) or before (if n < 0) the mark.
This function eventually calls delete-buffer-range, provided that n
is not zero.
@end deffn

@deffn {Generic Function} {delete-region} mark1 mark2

Delete the objects in the buffer that are between mark1 and mark2.  An
error is signaled if the two marks are positioned in different
buffers.  It is acceptable to pass an offset in place of one of the
marks.

This function calls delete-buffer-range with the appropriate arguments.
@end deffn

@node Getting Objects Out Of The Buffer
@subsubsection Getting Objects Out Of The Buffer

@deffn {Generic Function} {buffer-object} buffer offset

Return the object at the offset in the buffer.  The first object
has offset 0. If offset is less than zero, an offset-before-beginning
condition is signaled.  If offset is greater than or equal to
the size of the buffer, an offset-after-end condition is signaled.
@end deffn

@deffn {Generic Function} {buffer-sequence} buffer offset1 offset2

Return the contents of the buffer starting at offset1 and ending at
offset2-1 as a sequence.  If either of the offsets is less than zero,
an offset-before-beginning condition is signaled.  If either of the
offsets is greater than or equal to the size of the buffer, an
offset-after-end condition is signaled.  If offset2 is smaller than or
equal to offset1, an empty sequence will be returned.
@end deffn

@deffn {Generic Function} {object-before} mark

Return the object that is immediately before the mark.  If mark is at
the beginning of the buffer, an offset-before-beginning condition is
signaled.  If the mark is at the beginning of a line, but not at the
beginning of the buffer, a newline character is returned.
@end deffn

@deffn {Generic Function} {object-after} mark

Return the object that is immediately after the mark.  If mark is at
the end of the buffer, an offset-after-end condition is signaled.  If
the mark is at the end of a line, but not at the end of the buffer, a
newline character is returned.
@end deffn

@deffn {Generic Function} {region-to-sequence} mark1 mark2

Return a freshly allocated sequence of the objects between mark1 and
mark2.  An error is signaled if the two marks are positioned in
different buffers.  It is acceptable to pass an offset in place of one
of the marks.

This function calls buffer-sequence with the appropriate arguments.
@end deffn

@node Implementation Hints
@subsubsection Implementation Hints

The buffer is implemented as lines organized in a 2-3-tree.  The
leaves of the tree contain the lines, and the internal nodes contain
additional information of the left subtree (if it is a 2-node) or the
left and the middle subtree (if it is a 3-node).  Two pieces of
information are stored: The number of lines in up to and including
the subtree and the total number of objects up to an including the
subtree.  This organization allows us to determine, the line number
and object position of any mark in O(log N) where N is the number of
lines.

A line is an instance of the `buffer-line' class.  A line can either
be open or closed.  A closed line is represented as a sequence.  The
exact type of the sequence depends on the objects contained in the
line.  If the line contains only characters of type base-char, then
the sequence is of type base-string.  If the line contains only
characters, but not of type base-char, the sequence is a string.
Otherwise it is a vector of arbitrary objects.  This way, closed
lines containing characters with code points below 256 have a compact
representation with 8 bits per character while still allowing for
arbitrary objects when necessary.  An open line is represented as a
cursorchain of objects.

Marks in a closed line are represented as an integer offset into the
sequence.  Marks in an open line are represented as flexicursors.

When a line is opened, it is converted to a cursorchain.  When a line
is closed, it is examined to determine whether it contains
non-character objects, in which case it is converted to a vector of
objects.  If contains only characters, but it contains characters
with code points above what can be represented in a base-char, it is
converted to a string.  If it contains only base-chars, it is
converted to a base-string.

A mark contains two slots: a flexicursor that determines which line it
is on, and either an integer (if the line is closed) that determines
the offset within the line or another flexicursor (if the line is
open).  For each line, open or closed, a list of weak references to
marks into that line is kept.

Lines are closed according to a LRU scheme.  Whenever objects are
inserted to or deleted from a line, it becomes the most recently used
line.  We keep a fixed number of open lines so that when a line is
opened and the threshold is reached, the least recently used line is
closed.

@node Buffer Modification Protocol
@subsection Buffer Modification Protocol

The buffer maintains two marks, the low mark and the high mark:

@deffn {Generic Function} {low-mark} buffer

Return the low mark of the buffer.
@end deffn

@deffn {Generic Function} {high-mark} buffer

Return the high mark of the buffer.
@end deffn

The low mark is a left-sticky mark and high mark is a right-sticky
mark.  Whenever a modification is made to the buffer, the offset of
the low mark is set to the minimum of its current value and the
position of the modification.  Similarly, whenever a modification is
made to the buffer, the offset of the high mark is set to the maximum
of its current value and the position of the modification.

The redisplay module may use these values to determine what part of
the screen needs to be updated.  These values can also be used to
update information about syntax highlighting and other cached
information.

In addition to these marks, the buffer maintains a modification flag
that determines.  Whether the buffer has been modified since the last
call to clear-modify.

@deffn {Generic Function} {modified-p} buffer

Return true if and only if the buffer has beeen modified.
@end deffn

@deffn {Generic Function} {clear-modify} buffer

Set the high-mark to the beginning of the beginning of the buffer and
the low-mark to the end of the buffer, and clear the modification
flag.
@end deffn

This function is used by the redisplay module after all of the panes
on display have been redisplayed properly.  A call to this function
concludes the interaction loop and Drei is again ready to read and
execute commands.

@node DREI-BASE Package
@subsection DREI-BASE Package

The buffer protocol has been designed to be reasonably efficient with a
variety of different implementation strategies (single gap buffer or
sequence of independent lines).  It contains (and should only contain)
the absolute minimum of functionality that can be implemented
efficiently independently of strategy.  However, this minimum of
functionality is not always convenient.

The purpose of the @package{DREI-BASE} package is to implement
additional functionality on top of the buffer protocol, in a way that
does not depend on how the buffer protocol was implemented.  Thus, the
@package{DREI-BASE} package should remain intact across different
implementation strategies of the buffer protocol.

Achieving portability of the @package{DREI-BASE} package is not terribly
hard as long as only buffer protocol functions are used.  What is
slightly harder is to be sure to maximize efficiency across several
implementation strategies.  The next section discusses such
considerations and gives guidelines to implementers of additional
functionality.

Implementers of the buffer protocol may use the contents of the next
section to make sure they respect the efficiency considerations that are
expected by the @package{DREI-BASE} package.

@menu
* Efficiency Considerations::   
@end menu

@node Efficiency Considerations
@subsubsection Efficiency considerations

In this section, we give a list of rules that implementors of
additional functionality should follow in order to make sure that such
functionality remains efficient (in addition to being portable) across
a variety of implementation strategies of the buffer protocol.

@quotation Rule
Comparing the position of two marks is efficient, i.e. at most O(log n)
where n is the number of marks in the buffer (which is expected to be
very small compared to the number of objects) in all implementations.
This is true for all types of comparisons.
@end quotation

It is expected that marks are managed very efficiently.  Some balanced
tree management might be necessary, which will make operations have
logarithmic complexity, but only in the number of marks that are
actually used.

@quotation Rule
While computing and setting the offset of a mark is fairly efficient,
it is not guaranteed to be O(1) even though it might be in an
implementation using a single gap buffer.  It might have a complexity
of O(log n) where n is the number of lines in the buffer.  This is
true for using incf on the offset of a mark as well, as incf expands
to a setf of the offset.

Do not hesitate computing or setting the offset of a mark, but avoid
doing it in a tight loop over many objects of the buffer.
@end quotation

@quotation Rule
Determining whether a mark is at the beginning or at the end of the
buffer is efficient, i.e. O(1), in all implementations.
@end quotation

@quotation Rule
Determining whether a mark is at the beginning or at the end of a line
is efficient, i.e. O(1), in all implementations.
@end quotation

@quotation Rule
Going to the beginning or to the end of a line might have linear-time
complexity in the number of characters of the line, though it is
constant-time complexity if the implementation is line oriented.

It is sometimes inevitable to use this functionality, and since lines
are expected to be short, it should not be avoided at all cost,
especially since it might be very efficient in some implementations.
We do recommend, however to avoid it in tight loops.

Always use this functionality rather than manually incrementing the
offset of a mark in a loop until a Newline character has been found,
especially since each iteration might take logarithmic time then.
@end quotation

@quotation Rule
Computing the size of the buffer is always efficient, i.e., O(1).
@end quotation

@quotation Rule
Computing the number of lines of the buffer is always efficient, i.e.,
O(1).
@end quotation

Implementations of the buffer protocol could always track the number
of insertions and deletions of objects, so there is no reason why this
operation should be inefficient.

@quotation Rule
Computing the line number of a mark or of an offset can be very
costly, i.e. O(n) where n is size of the buffer.
@end quotation

This operation is part of the buffer protocol because some
implementations may implement it fairly efficiently, say O(log n)
where n is the number of lines in the buffer.

@node Syntax Protocol
@subsection Syntax Protocol

A buffer always has a syntax module associated with it.  The syntax
module usually consists of an incremental parser that analyzes the
contents of the buffer and creates some kind of parse tree or other
representation of the contents in order that it can be exploited by the
redisplay module and by user commands.

@menu
* General Syntax Protocol::     
* Incremental Parsing Framework::  
* Lexical Analysis::            
* Earley Parser::               
* Specifying A Grammar::        
* Common Lisp Syntax::          
@end menu

@node General Syntax Protocol
@subsubsection General Syntax Protocol

@deftp {Protocol Class} syntax

The base class for all syntaxes.
@end deftp

The redisplay module exploits the syntax module for several things:

@itemize @bullet
@item highlighting of various syntactic entities of the buffer
@item highlighting of matching parenthesis,
@item turning syntactic entities into clickable presentations,
@item marking lines with inconsistent indentation,
@item etc.
@end itemize

User commands can use the syntax module for:

@itemize @bullet
@item moving point by units that are specific to a particular buffer
syntax, such as expressions, statements, or paragraphs,
@item transposing syntactic units,
@item sending the text of a syntactic unit to a language processor,
@item indenting lines according to the syntax,
@item etc.
@end itemize

The view that the syntax module has of the buffer is updated only when
needed, and then only for the parts of the buffer that are needed.
Most syntax modules (such as for programming languages) need to
compute their representations from the beginning of the buffer up to a
particular point beyond which the structure of the buffer does not
need to be known.

There are three situations where updating might be needed:

@itemize @bullet
@item once, before any panes are displayed to inform the syntax module
that some part of the buffer has been altered,
@item once for each pane on display, before redisplay is about to show
the contents of part of the buffer in a pane to inform the syntax
module that its syntax must be valid in the particular region on
display,
@item as a result of a command that exploits the syntactic entities of
the buffer contents.
@end itemize

The first case is handled by the redisplay invoking the following
generic function:

@deffn {Generic Function} {update-syntax} buffer syntax

Inform the syntax module that it must update its view of the buffer
The low-mark and the high-mark of the buffer indicate what region has
been updated. It is acceptable to pass an offset instead of the mark.
@end deffn

The second case is handled by the following generic function:

@deffn {Generic Function} {update-syntax-for-display} buffer syntax from to

Inform the syntax module that it must update its syntactic analysis to
cover the region between the two marks from and to.  It is acceptable
to pass an offset instead of a mark for either or both of the last
two arguments.
@end deffn

The third case is handled by the syntax module itself when needed in
order to correctly compute the effects of a command.

It is important to realize that the syntax module is not directly
involved in displaying buffer contents in a pane.  In fact, the syntax
module should work even if there is no graphic user interface
present, and it should be exploitable by several, potentially totally
different, display units.

@node Incremental Parsing Framework
@subsubsection Incremental Parsing Framework

@deftp {Protocol Class} parse-tree

The base class for all parse trees.
@end deftp

We use the term parse tree in a wider sense than what is common in the
parsing literature, in that a lexeme is a (trivial) parse tree.  The
parser does not distinguish between lexemes and other parse trees, and
a grammar rule can produce a lexeme if that should be desired.

@deffn {Generic Function} {start-offset} parse-tree

The offset in the buffer of the first character of a parse tree.
@end deffn

@deffn {Generic Function} {end-offset} parse-tree

The offset in the buffer of the character following the last one of a
parse tree.
@end deffn

The length of a parse-tree is thus the difference of its end offset
and its start offset.

The start offset and the end offset may be NIL which is typically the
case when a parse tree is derived from the empty sequence of lexemes.

@node Lexical Analysis
@subsubsection Lexical analysis

@deftp {Protocol Class} lexer

The base class for all lexers.
@end deftp

@deftp {@class{lexer} Initarg} :buffer

Associate a buffer with a lexer
@end deftp

@deffn {Generic Function} {buffer} lexer

Return the buffer associated with the lexer
@end deffn

@deftp {Class} incremental-lexer

A subclass of lexer which maintains the buffer in the form of a
sequence of lexemes that is updated incrementally.
@end deftp

In the sequence of lexemes maintained by the incremental lexer, the
lexemes are indexed by a position starting from zero.

@deffn {Generic Function} {nb-lexemes} lexer

Return the number of lexemes in the lexer.
@end deffn

@deffn {Generic Function} {lexeme} lexer pos

Given a lexer and a position, return the lexeme in that position in
the lexer.
@end deffn

@deffn {Generic Function} {insert-lexeme} lexer pos lexeme

Insert a lexeme at the position in the lexer.  All lexemes following
POS are moved to one position higher.
@end deffn

@deffn {Generic Function} {delete-invalid-lexemes} lexer from to

Invalidate all lexemes that could have changed as a result of
modifications to the buffer
@end deffn

@deffn {Generic Function} {inter-lexeme-object-p} lexer object

This generic function is called by the incremental lexer to determine
whether a buffer object is an inter-lexeme object, typically
whitespace. Client code must supply a method for this generic
function.
@end deffn

@deffn {Generic Function} {skip-inter-lexeme-objects} lexer scan

This generic function is called by the incremental lexer to skip
inter-lexeme buffer objects.  The default method for this generic
function increments the scan mark until the object after the mark is
not an inter-lexeme object, or until the end of the buffer has been
reached.
@end deffn

@deffn {Generic Function} {update-lex} lexer start-pos end

This function is called by client code as part of the buffer-update
protocol to inform the lexer that it needs to analyze the contents of
the buffer at least up to the END mark of the buffer.  START-POS is
the position in the lexeme sequence at which new lexemes should be
inserted.
@end deffn

@deffn {Generic Function} {next-lexeme} lexer scan
This generic function is called by the incremental lexer to get a new
lexeme from the buffer.  Client code must supply a method for this
function that specializes on the lexer class.  It is guaranteed that
scan is not at the end of the buffer, and that the first object after
scan is not an inter-lexeme object.  Thus, a lexeme should always be
returned by this function.
@end deffn

@node Earley Parser
@subsubsection Earley Parser

Drei contains an incremental parser that uses the Earley
algorithm.  This algorithm accepts the full set of context-free
grammars, allowing greater freedom for the developer to define natural
grammars without having to think about restrictions such as LL(k) or
LALR(k).

Beware, though, that the Earley algorithm can be quite inefficient if
the grammar is sufficiently complicated, in particular if the grammar
is ambiguous.

@node Specifying A Grammar
@subsubsection Specifying A Grammar

An incremental parser is created from a grammar.

@defmac {grammar} &body rules

Create a grammar object from a set of rules
@end defmac

@deftp {Rule} {} symbol -> (&rest arguments) &optional body

Each rule is a list of this form.
@end deftp

@noindent
Here @var{symbol} is the target symbol of the rule, and should be the name of
a CLOS class.

@deffn {Rule argument} {} (var type test)

The most general form of a rule argument.
@end deffn

@noindent
Here @var{var} is the name of a lexical variable.  The scope of the
variable contains the test, all the following arguments and the body
of the rule.  The @var{type} is a Common Lisp type specification.  The
rule applies only of the @var{type} of the object contain in var is of
that type.  The @var{test} contains arbitrary Common Lisp code for
additional checks as to the applicability of the rule.

@deffn {Rule argument} {} (var type)

Abbreviated form of a rule argument.
@end deffn

@noindent
Here, @var{type} must be a symbol typically the name of a CLOS class.
This form is an abbreviation for @code{(@var{var} @var{type} t)}.

@deffn {Rule argument} {} (var test)

Abbreviated form of a rule argument.
@end deffn

@noindent
Here, @var{test} must not be a symbol.  This form is an abbreviation
of @code{(@var{var} @var{var} @var{test})}, i.e., the name of the
variable is also the name of a type, typically a CLOS class.

@deffn {Rule argument} {} var

Abbreviated form of a rule argument.
@end deffn

@noindent
This form is an abbreviation of @code{(@var{var} @var{var} t)}.

The @var{body} of a rule, if present, contains an expression that should
have an instance (not necessarily direct) of the class named by the
symbol (the left-hand-side) of the rule.  It is important that this
restriction be respected, since the Earley algorithm will not work
otherwise.

If the @var{body} is absent, it is the same as if a body of the form
@code{(make-instance '@var{symbol})} had been given.

The body can also be a sequence of forms, the first one of which
must be a symbol.  These forms typically contain initargs, and will be
passed as additional arguments to @code{(make-instance '@var{symbol})}.

@node Common Lisp Syntax
@subsubsection Common LiSp Syntax

Technically, comments and such are not expressions, but it is OK for
our purposes to consider that they are.

@multitable @columnfractions .2 .1 .5
@item program @tab -> @tab expr*
@item expr @tab -> @tab quoted-expression
@item expr @tab -> @tab comment
@item expr @tab -> @tab string
@item expr @tab -> @tab backquote-expression
@item expr @tab -> @tab unquote-expression
@item expr @tab -> @tab list-expression
@item expr @tab -> @tab label-ref
@item expr @tab -> @tab function-expression
@item expr @tab -> @tab vector-expression
@item expr @tab -> @tab array-expression
@item expr @tab -> @tab bitvector-expression
@item expr @tab -> @tab labeled-expression
@item expr @tab -> @tab character
@item expr @tab -> @tab balanced-comment
@item expr @tab -> @tab read-time-conditional-+
@item expr @tab -> @tab read-time-conditional--
@item expr @tab -> @tab read-time-evaluation
@item expr @tab -> @tab binary-expression
@item expr @tab -> @tab complex-expression
@item expr @tab -> @tab octal-expression
@item expr @tab -> @tab pathname-expression
@item expr @tab -> @tab radix-n-expression
@item expr @tab -> @tab hex-expression
@item expr @tab -> @tab token
@end multitable

@multitable @columnfractions .3 .3 .3
@item Expression @tab Syntax @tab handle/read
@item quoted-expression @tab 'expr  @tab handle
@item comment @tab ; chars <newline> @tab handle
@item string @tab " chars " @tab read
@item backquote-expression @tab ` expr @tab handle
@item unquote-expression @tab , expr @tab handle
@item list-expression @tab ( expr* ) @tab handle
@item label-ref @tab #n# @tab handle
@item function-expression @tab #' expr @tab handle
@item vector-expression @tab #( expr* ) @tab handle
@item array-expression @tab #nA(...) @tab handle
@item bitvector-expression @tab #* bits @tab read
@item labeled-expression @tab #n= @tab handle
@item character @tab #\.. @tab read
@item balanced-comment @tab #| .. |# @tab handle
@item read-time-conditional-+ @tab #+test expr @tab handle
@item read-time-conditional-- @tab #-test expr @tab handle
@item read-time-evaluation @tab #.expr @tab handle
@item binary-expression @tab #b... @tab read
@item complex-expression @tab #c... @tab read
@item octal-expression @tab #o... @tab read
@item pathname-expression @tab #p... @tab read
@item radix-n-expression @tab #nr @tab read
@item hex-expression @tab #x @tab read
@end multitable

@deftp {Class} stack-entry

A stack entry corresponds to a syntactic category and contains a
start offset and an end offset.  The end offset is initialized to
nil, meaning we do not know where it ends.
@end deftp

@deftp {@class{stack-entry} Initarg} :start-offset
@end deftp

@deftp {Class} error-entry

This is a subclass of stack-entry.  It is used whenever some invalid
input syntax is encountered.
@end deftp

@deftp {Class} terminal-entry

This is a subclass of stack-entry.  It is used for tokens (numbers,
symbols), but also for macro characters that start more complex
expressions.
@end deftp

@deftp {Class} number-entry

A subclass of terminal-entry corresponding to the syntactic class of
numbers.
@end deftp

@deftp {Class} symbol-entry

A subclass of terminal-entry corresponding to the syntactic class of
symbols.
@end deftp

@deftp {Class} character-entry

A subclass of terminal-entry corresponding to the syntactic class of
characters.
@end deftp

@deftp {Class} string-entry

A subclass of terminal-entry corresponding to the syntactic class of
character strings
@end deftp

@deftp {Class} quote-entry

A subclass of terminal-entry corresponding to the syntactic class of
quote inidicators.
@end deftp

@deftp {Class} backquote-entry

A subclass of terminal-entry corresponding to the syntactic class of
backquote indicators.
@end deftp

@deftp {Class} unquote-entry

A subclass of terminal-entry corresponding to the syntactic class of
unquote indicators.
@end deftp

@deftp {Class} comment-entry

A subclass of terminal-entry corresponding to the syntactic class of
single-line comment indicators.
@end deftp

@deftp {Class} list-start-entry

A subclass of terminal-entry corresponding to the syntactic class of
list start indicators.
@end deftp

@deftp {Class} list-end-entry

A subclass of terminal-entry corresponding to the syntactic class of
list end indicators.
@end deftp

@deftp {Class} label-ref-entry

A subclass of terminal-entry corresponding to the syntactic class of
label reference indicators.
@end deftp

@deftp {Class} label-entry

A subclass of terminal-entry corresponding to the syntactic class of
label indicators.
@end deftp

@deftp {Class} function-entry

A subclass of terminal-entry corresponding to the syntactic class of
function indicators.
@end deftp

@deftp {Class} balanced-comment-entry

A subclass of terminal-entry corresponding to the syntactic class of
balanced comment entry indicators.
@end deftp

@deftp {Class} read-time-conditional-entry

A subclass of terminal-entry corresponding to the syntactic class of
read-time conditional indicators.
@end deftp

@deftp {Class} vector-entry

A subclass of terminal-entry corresponding to the syntactic class of
vector indicators.
@end deftp

@deftp {Class} array-entry

A subclass of terminal-entry corresponding to the syntactic class of
array indicators.
@end deftp

@deftp {Class} bitvector-entry

A subclass of terminal-entry corresponding to the syntactic class of
bit vector indicators.
@end deftp

@deftp {Class} read-time-evaluation-entry

A subclass of terminal-entry corresponding to the syntactic class of
read-time evaluation indicators.
@end deftp

@deftp {Class} complex-entry

A subclass of terminal-entry corresponding to the syntactic class of
complex indicators.
@end deftp

@deftp {Class} octal-entry

A subclass of terminal-entry corresponding to the syntactic class of
octal rational indicators.
@end deftp

@deftp {Class} hex-entry

A subclass of terminal-entry corresponding to the syntactic class of
hex rational indicators.
@end deftp

@deftp {Class} radix-n-entry

A subclass of terminal-entry corresponding to the syntactic class of
radix-n rational indicators.
@end deftp

@deftp {Class} pathname-entry

A subclass of terminal-entry corresponding to the syntactic class of
pathname indicators.
@end deftp

@deftp {Class} binary-entry

A subclass of terminal-entry corresponding to the syntactic class of
binary rational indicators.
@end deftp

@deftp {Class} unknown-entry

A subclass of terminal-entry corresponding to unknown (user-defined)
syntactic classes.
@end deftp

@deftp {Class} nonterminal-entry

This is a subclass of stack-entry.  A nonterminal entry maintains an
expression count, which is initialized to 0.  It corresponds to the
number of subexpressions of this expression that have been detected.
A nonterminal entry also maintains a backquote-depth which is
initially 0, is incremented by 1 for each nested backquote, and is
decremented by 1 for each comma.
@end deftp

@deffn {Generic Function} expression-count nonterminal-entry

Return the expression count of this entry.
@end deffn

@deffn {Generic Function} {(setf expression-count)} count nonterminal-entry

Set the expression count of this entry.
@end deffn

@deffn {Generic Function} backquote-depth nonterminal-entry

Return the backquote-depth of this entry.
@end deffn

@deffn {Generic Function} {(setf backquote-depth)} depth nonterminal-entry

Set the backquote-depth of this entry.
@end deffn

@deftp {Class} program-entry

A subclass of nonterminal-entry corresponding to the entire buffer
contents.
@end deftp

@deftp {Class} quoted-expression-entry

A subclass of nonterminal-entry corresponding to a quoted
expression.
@end deftp

@deftp {Class} unquoted-expression-entry

A subclass of nonterminal-entry corresponding to an unquoted
expression.
@end deftp

@deftp {Class} list-expression-entry

A subclass of nonterminal-entry corresponding to a list expression.
@end deftp

@deftp {Class} function-expression-entry

A subclass of nonterminal-entry corresponding to a function
expression.
@end deftp

@deftp {Class} vector-expression-entry

A subclass of nonterminal-entry corresponding to a vector expression.
@end deftp

@deftp {Class} labeled-expression-entry

A subclass of nonterminal-entry corresponding to a labeled expression.
@end deftp

@deftp {Class} array-expression-entry

A subclass of nonterminal-entry corresponding to a list expression.
@end deftp

@deftp {Class} array-dimension-entry

A subclass of nonterminal-entry corresponding to an array dimension.
@end deftp

@deftp {Class} read-time-feature-entry

A subclass of nonterminal-entry corresponding to a read-time
feature.
@end deftp

@deftp {Class} read-time-conditional-expression-entry

A subclass of nonterminal-entry corresponding to a read-time
conditional expression.
@end deftp

@deftp {Class} read-time-evaluation-expression-entry

A subclass of nonterminal-entry corresponding to a read-time
evaluation expression.
@end deftp

@deftp {Class} complex-expression-entry

A subclass of nonterminal-entry corresponding to a complex
expression.
@end deftp

@deftp {Class} octal-expression-entry

A subclass of nonterminal-entry corresponding to an octal expression.
@end deftp

@deftp {Class} hex-expression-entry

A subclass of nonterminal-entry corresponding to a hexadecimal
expression.
@end deftp

@deftp {Class} radix-n-expression-entry

A subclass of nonterminal-entry corresponding to a radix-n
expression.
@end deftp

@deftp {Class} pathname-expression-entry

A subclass of nonterminal-entry corresponding to a pathname
expression.
@end deftp

@deftp {Class} binary-expression-entry

A subclass of nonterminal-entry corresponding to binary expression.
@end deftp

@deftp {Class} buffer-stream

A stream corresponding to a text buffer.  It contains a current parse
stack which is a list of stack entries.
@end deftp

@deftp {@class{buffer-stream} Initarg} :buffer

The buffer underlying the stream.
@end deftp

@deffn {Generic Function} current-offset buffer-stream

Return the current offset of the buffer stream.
@end deffn

@deffn {Generic Function} {(setf current-offset)} offset buffer-stream

set the current offset of the buffer stream.
@end deffn

@deffn {Generic Function} max-offset buffer-stream

Return the maximum offset of the buffer stream, beyond which no
parsing is required.
@end deffn

@deffn {Generic Function} {(setf max-offset)} offset buffer-stream

set the maximum offset of the buffer stream.
@end deffn

@deffn {method} stream-read-char buffer-stream

Return the character at the current offset (or :eof if the offset is
equal to the size of the buffer)
@end deffn

@deffn {Generic Function} parse-stack buffer-stream

Return the current parse stack of the buffer stream.  The parse stack
contains either all nonterminals, or all but the top element
nonterminal.  The list of entries is initially a list of a single
entry corresponding to the syntactic category `program-entry' with a
start offset of 0 and an expression count of 0.
@end deffn

@deffn {Generic Function} {(setf parse-stack)} stack buffer-stream

Set the current parse stack of the buffer.
@end deffn

@deffn {Generic Function} analysis buffer-stream

An adjustable vector each element of which is a parse stack with top
element being terminal. The vector is initially empty.
@end deffn

@deffn {Generic Function} invalidate-parse buffer-stream offset

Called by client code to indicate that the buffer has been altered
starting at the offset indicated.  The analysis vector of the buffer
stream is shortened to the last entry ending before or at the
offset.  The parse stack is set to the tail of the stack at the last
entry of the analysis vector. The current offset is set to the end
offset of the last entry of the analysis vector.
@end deffn

@deffn {Generic Function} advance-parse buffer-stream offset

Inform the parser that it should construct a valid analysis vector up
to the offset indicated.  The redisplay module will call this
function with the highest offset of all the windows on display before
calling display-region for each window.  The algorithm is as follows:

  Set the max offset of the buffer stream to the offset passed as
  argument.
  Loop until the current offset is greater than or equal to max
  offset (i.e., EOF on the buffer stream is reached):
    Remember the current offset
    Read a character
    If it is a whitespace,
      do nothing
    Else if it is a single-dispatch-macro character
      Call parse-macro-character with the buffer stream, the value of
      a call to get-macro-character of the character, the
      top-element of the current parse stack, and the remembered
     offset.
    Else
      Unread the character and call `read' on the stream.
      Add an entry to the end of the analysis vector containing as
      start offset the remembered offset, as end offset the current
      offset after the call to read, and a stack containing the
      current parse stack with an additional entry on top
      corresponding to the item read (number, symbol, etc).
      Increment the expression count of the top of the stack.
      Perform a count check (see below).
@end deffn

@deffn {Generic Function} parse-macro-character buffer-stream function entry o

This generic function is called with a buffer stream, with a function
that is returned by a call to get-macro-character, the top-entry
of the current parse stack, and a remembered offset.
@end deffn

It has a number of methods, each one specialized (using an eql
specializer) on a function returned by a call to get-macro-character
in standard syntax.  We indicate here the character itself, but it is
the associated function that is actually used.

@table @samp
@item ) nonterminal-entry
@itemize @bullet
@item
Add an entry at the end of the analysis vector with the current
stack augmented with an entry for `error-entry' with a start offset
of the remembered offset and an end offset of the current offset.
@end itemize
@item ) vector-expression-entry
@itemx ) list-expression-entry
@itemx ) array-expression-entry
@itemize @bullet
@item
Set the end offset of the entry on top of the stack to the current
offset.
@item
Pop the current stack.
@item
Increment the expression count of the top of the stack.
@item
Perform a count check (see below)
@item
Add an entry at the end of the analysis vector with the current
stack augmented with an entry for `list-end-entry' with a start
offset of the remembered offset, and an end offset of the current
offset
@end itemize

@item ) nonterminal-entry
@itemize @bullet
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `error-entry' with a start offset
  of the remembered offset and an end offset of the current offset.
@end itemize

@item ) vector-expression-entry
@itemx ) list-expression-entry
@itemx ) array-expression-entry
@itemize @bullet
@item
  Set the end offset of the entry on top of the stack to the current
  offset.
@item
  Pop the current stack.
@item
  Increment the expression count of the top of the stack.
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `list-end-entry' with a start
  offset of the remembered offset, and an end offset of the current
  offset.
@end itemize

@item ; nonterminal-entry
@itemize @bullet
@item
  Read characters until a newline has been read.
@item
  Add an entry to the end of the analysis vector with the current
  stack augmented with an entry for `comment-entry' with a start
  offset of the remembered offset and the end offset of the current
  offset.
@end itemize

@item ' nonterminal-entry
@itemize @bullet
@item
  Push an entry for quoted-expression-entry on the stack with a
  backquote-depth of one plus that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `quote-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.
@end itemize

@item ` nonterminal-entry
@itemize @bullet
@item
  Push an entry for quoted-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack plus one.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `backquote-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.
@end itemize

@item , nonterminal-entry
@itemize @bullet
@item
  If the backquote-depth of the top of the stack is greater than 0
@itemize @bullet
@item
    Push an entry for unquoted-expression-entry on the stack  with a
    backquote-depth of that of the current top of the stack minus
    one.
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `unquote-entry' with a
    start offset of the remembered offset and an end offset of
    the current offset.
@end itemize
@item
  Else
@itemize @bullet
@item
    Push an entry for unquoted-expression-entry on the stack  with a
    backquote-depth of 0.
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `error-entry' with a start
    offset of the remembered offset and an end offset of the current
    offset.
@end itemize
@end itemize

@item ( nonterminal-entry
@itemize @bullet
@item
  Push an entry for list-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `list-start-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.
@end itemize

@item " nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character.
  Increment the expression count of the top of the stack.
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `string-entry' with a start
  offset of the remembered offset and an end offset of the current
  offset.
@end itemize

@item # nonterminal-entry
@itemize @bullet
@item
  Remember the first char.
@item
  Read characters as long as they are digits, and form a count (a
  number or nil if there are no digits).
@item
  If the first non-digit character is a dispatch macro character
@itemize @bullet
@item
    Call parse-dispatch-macro-character with the buffer stream, the
    result of a call to get-dispatch-macro-character, the entry, and
    the remembered offset
@end itemize
@item
  Else
@item
    Add an entry at the end of the analysis vector with the current
    stack augmented with an entry for `error-entry' with a start
    offset of the remembered offset and an end offset of the current
    offset.
@end itemize

@item any nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `unknown-entry' with a start
  offset of the remembered offset and an end offset of the
  current offset.
@end itemize
@end table

@deffn {Generic Function} parse-dispatch-macro-character buffer-stream function entry o
@end deffn

@table @samp
@item # nonterminal-entry
@itemize @bullet
@item
  Increment the expression count of the top of the stack.
@item
  Perform a count check (see below).
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `label-ref-entry' with a
  start offset of the remembered offset and an end offset of
  the current offset.
@end itemize

@item ' nonterminal-entry
@itemize @bullet
@item
  Push an entry for function-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for function-entry with a start
  offset of the remembered offset and the end offset of the current
  offset.
@end itemize

@item ( nonterminal-entry
@itemize @bullet
@item
  Push an entry for vector-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for vector-entry with a start offset
  of the remembered offset and the end offset of the current offset.
@end itemize

@item A nonterminal-entry
  [to be filled in]

@item = nonterminal-entry
@itemize @bullet
@item
  Push an entry for labeled-expression-entry on the stack with a
  backquote-depth of that of the current top of the stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for label-entry with a start offset
  of the remembered offset and the end offset of the current offset.
@end itemize

@item | nonterminal-entry
@itemize @bullet
@item
  Read characters until a |# pair has been seen or EOF is reached.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for balanced-comment-entry with a
  start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item + nonterminal-entry
@itemx - nonterminal-entry
@itemize @bullet
@item
  Push an entry for read-time-conditional-expression-entry on the
  stack with a backquote-depth of that of the current top of the
  stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for read-time-conditional-entry with
  a start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item . nonterminal-entry
@itemize @bullet
@item
  Push an entry for read-time-evaluation-expression-entry on the
  stack with a backquote-depth of that of the current top of the
  stack.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with the entry for read-time-evaluation-entry with
  a start offset of the remembered offset and the end offset of the
  current offset.
@end itemize

@item any nonterminal-entry
@itemize @bullet
@item
  Call the function associated with the character.
@item
  Add an entry at the end of the analysis vector with the current
  stack augmented with an entry for `unknown terminal' with a start
  offset of the remembered offset and an end offset of the
  current offset.
@end itemize
@end table

@deffn {Generic Function} count-check nonterminal-entry

A count check means that we compare the expression count of the top of
the stack and its syntactic category.  If the category has a limited
number of expressions allowed, and we have reached it, we pop off the
top element, increment the expression count of the new top entry, and
perform a count check again.
@end deffn

@node Unit Protocol
@subsection Unit Protocol
@cindex Drei unit protocol
@cindex Drei motion protocol
@cindex Drei editing protocol

Many of the actions performed by an editor is described in terms of the
syntactically unit(s) they affect. The syntax module is responsible for
actually dividing the buffer into syntactical units, but the @i{unit
protocol} is the basic interface for acting on these units. A @i{unit}
is some single syntactical construct - for example a word, a sentence,
an expression or a definition. The unit protocol defines a number of
generic functions for the various unit types that permit a uniform
interface to moving a mark a given number of units, deleting a unit,
killing a unit, transposing two units and so forth. A number of macros
are also provided for automatically generating all these functions,
given the definition of two simple movement functions. All generic
functions of the unit protocol dispatch on a syntax, so that every
syntax can implement its own idea of what exactly, for example, an
``expression'' is. Defaults are provided for some units - if nothing
else has been specified by the syntax, a word is considered any sequence
of alphanumeric characters delimited by non-alphanumeric characters.
@cindex unit

The type of unit that a protocol function affects is represented
directly in the name of the function - this means that a new set of
functions must be generated for every new unit you want the protocol to
support. In most cases, the code for these functions is very repetitive
and similar across the unit types, which is why the motion protocol
offers a set of macros that can generate function definitions for
you. These generator macros define their generated functions in terms of
basic motion functions.

A basic motion function is a function named @cl{FORWARD-ONE-@var{unit}}
or @cl{backward-one-@var{unit}} of the signature @cl{(@var{mark}
@var{syntax})} that returns true if any motion happened or false if a
limit was reached.
@cindex basic motion function

There isn't really a single all-encompassing unit protocol, instead, it
is divided into two major parts - a motion protocol defining functions
for moving point in terms of units, and an editing protocol for changing
the buffer in terms of units. Both use a similar interface and a general
mechanism for specifying the action to take if the intended operation
cannot be carried out.

Note that @cl{forward-object} and @cl{backward-object}, by virtue of
their low-level status and placement in the buffer protocol (see
buffer.lisp) do not obey this protocol, in that they have no syntax
argument. Therefore, all @cl{@var{frob}-object} functions and commands
(@pxref{Editing Protocol}) lack this argument as well. There are no
@cl{forward-one-object} or @cl{backward-one-object} functions.

@menu
* Motors And Limit Actions::    
* Motion Protocol::             
* Editing Protocol::            
* Generator Macros::            
@end menu

@node Motors And Limit Actions
@subsubsection Motors And Limit Actions

A limit action is a function usually named
@cl{@var{mumble}-limit-action} of the signature @cl{(@var{mark}
@var{original-offset} @var{remaining-units} @var{unit} @var{syntax})}
that is called whenever a general motion function cannot complete the
motion. @var{Mark} is the mark the object in motion;
@var{original-offset} is the original offset of the mark, before any
motion; @var{remaining-units} is the number of units left until the
motion would be complete; @var{unit} is a string naming the unit; and
@var{syntax} is the syntax instance passed to the motion function. There
is a number of predefined limit actions:
@cindex limit action

@deffn {Function} {beep-limit-action} {(mark original-offset remaining unit syntax)}
@findex beep-limit-action

This limit action will beep at the user.
@end deffn

@deffn {Function} {revert-limit-action} {(mark original-offset remaining unit syntax)}
@findex revert-limit-action

This limit action will try to restore the mark state before the
attempted action. Note that this will not restore any destructive
actions that have been performed, it will only restore the position of
@var{mark}.
@end deffn

@deftp {Error Condition} {motion-limit-error}
@findex motion-limit-error

This error condition signifies that a motion cannot be performed.
@end deftp

@deffn {Function} {error-limit-action} (mark original-offset remaining)
@findex error-limit-action

This limit action will signal an error of type @cl{motion-limit-error}.
@end deffn

A @i{diligent motor} is a combination of two motion functions that has
the same signature as a standard motion function (@pxref{Motion
Protocol}). The primary motion function is called the @i{motor} and the
secondary motion function is called the @i{fiddler}. When the diligent
motor is called, it will start by calling its motor - if the motor
cannot carry out its motion, the fiddler will be called, and if the
fiddler is capable of performing its motion, the motor will be called
again, and if this second motor call also fails, the fiddler will be
called yet again, etc. If at any time the call to the fiddler fails, the
limit action provided in the call to the diligent motor will be
activated. A typical diligent motor is the one used to implement a
@t{Backward Lisp Expression} command - it attempts to move backwards by
a single expression, and if that fails, it tries to move up a level in
the expression tree and tries again.
@cindex limit-action

@deffn {Function} {make-diligent-motor} (motor fiddler)
@findex make-diligent-motor

Create and return a diligent motor with a default limit action of
@cl{beep-limit-action}. @var{Motor} and @var{fiddler} will take turns
being called until either @var{motor} succeeds or @var{fiddler} fails.
@end deffn

@node Motion Protocol
@subsubsection Motion Protocol

The concept of a @i{basic motion function} was introduced in @ref{Unit
Protocol}. A general motion function is a function named
@cl{forward-@var{unit}} or @cl{backward-@var{unit}} of the signature
@cl{(@var{mark} @var{syntax} &optional (@var{count} 1)
(@var{limit-action} #'ERROR-LIMIT-ACTION))} that returns true if it
could move forward or backward over the requested number of units,
@var{count}, which may be positive or negative; and calls the limit
action if it could not, or returns @cl{NIL} if the limit action is
@cl{NIL}.

@node Editing Protocol
@subsubsection Editing Protocol

An editing function is a function named
@cl{forward-@var{frob}-@var{unit}} or
@cl{backward-@var{frob}-@var{unit}}, or just @cl{@var{frob}-@var{unit}}
in the case where discering between forward and backward commands does
not make sense (an example is @cl{transpose-@var{unit}}).

A proper unit is a unit for which all the functions required by the
motion protocol has been implemented, this can be trivially done by
using the macro @cl{define-motion-commands} (@pxref{Generator Macros}).

@node Generator Macros
@subsubsection Generator Macros

@node Redisplay Protocol
@subsection Redisplay Protocol
@cindex Drei redisplay
@cindex text-editor redisplay

A buffer can be on display in several panes, possibly by being located
in several Drei instances. Thus, the buffer does not concern itself with
redisplay, but assumes that its host Drei instance will redisplay when
appropriate. There is no predictable definitive rule for when a Drei
will be redisplayed, but when it is, it will be done by calling the
following generic function.

@deffn {Generic Function} {display-drei} frame drei
@findex display-drei

@var{Drei} must be an object of type @class{drei} and @var{frame} must
be a CLIM frame containing the editor pane of @var{drei}. If you define
a new subclass of @var{drei}, you must define a method for this generic
function. In most cases, methods defined on this function will merely be
a trampoline to a function specific to the given Drei.
@end deffn

The redisplay engine supports syntax-specific customization of the
display in order to facilitate such functionality as syntax
highlighting. This is done through the following two generic functions,
both of which have sensible default methods defined by the Fundamental
syntax, so if your syntax is a subclass of @class{fundamental-syntax},
you do not need to define them.

@deffn {Generic Function} {display-drei-contents} stream drei syntax
@findex display-drei-contents

The purpose of this function is to display the buffer contents of a Drei
instance to some output surface. @var{Stream} is the CLIM output stream
that redisplay should be performed on, @var{drei} is the Drei instance
that is being redisplayed, and @var{syntax} is the syntax object of the
buffer in @var{drei}. Methods on this generic function can draw whatever
they want, but they should not assume that they are the only user of
@var{stream}, unless the @var{stream} argument has been specialized to
some application-specific pane class that can guarantee this. For
example, when accepting multiple values using the
@code{accepting-values} macro, several Drei instances will be displayed
simultaneously on the same stream. It is permitted to only specialise
@var{stream} on @class{clim-stream-pane} and not
@class{extended-output-stream}. When writing methods for this function,
be aware that you cannot assume the buffer will only contain characters,
and that any subsequence of the buffer is coercable to a string. Drei
buffers can contain arbitrary objects, and redisplay methods are
required to handle this (though they are not required to handle it
nicely, they can just ignore the object, or display the @code{princ}ed
representation.)
@end deffn

@deffn {Generic Function} {display-drei-cursor} stream drei cursor syntax
@findex display-drei-cursor

The purpose of this function is to display a visible indication of a
cursor of a Drei instance to some output surface. @var{Stream} is the
CLIM output stream that drawing should be performed on, @var{drei} is
the Drei instance that is being redisplayed, @var{cursor} is the cursor
object to be displayed (a subclass of @class{drei-cursor}) and
@var{syntax} is the syntax object of the buffer in @var{drei}. Methods
on this generic function can draw whatever they want, but they should
not assume that they are the only user of @var{stream}, unless the
@var{stream} argument has been specialized to some application-specific
pane class that can guarantee this. It is permitted to only specialise
@var{stream} on @class{clim-stream-pane} and not
@class{extended-output-stream}. It is recommended to use the function
@code{offset-to-screen-position} to determine where to draw the visual
representation for the cursor. It is also recommended to use the ink
specified by @var{cursor} to perform the drawing, if applicable. This
method will only be called by the Drei redisplay engine when the cursor
is active and the buffer position it refers to is on display -
therefore, @code{offset-to-screen-position} is @emph{guaranteed} to not
return @cl{NIL} or @cl{T}.
@end deffn

@node Undo Protocol
@subsection Undo Protocol

Undo is the facility by which previous modifications to the buffer can
be undone, returning the buffer state to what it was prior to some
modification.

Undo is organized into a separate module.  This module conceptually
maintains a tree where the nodes represent application states and the
arcs represent transitions between these states.  The root of the tree
represents the initial state of the application.  The undo module also
maintains a current state.  During normal application operation, the
current state is a leaf of a fairly long branch of the tree.  Normal
application operations add new nodes to the end of this branch.  Moving
the current state up the tree corresponds to an undo operation and
moving it down some branch corresponds to some redo operation.

Arcs in the tree are ordered so that they always point FROM the current
state.  When the current state moves from one state to the other, the
arc it traversed is reversed.  The undo module does this by calling a
generic function that client code must supply a method for.

@menu
* Protocol Specification::      
* Implementation::              
* How The Buffer Handles Undo::  
@end menu

@node Protocol Specification
@subsubsection Protocol Specification

@deftp {error condition} no-more-undo

A condition of this type is signaled whenever an attempt is made to
call undo when the application is in its initial state.
@end deftp

@deftp {Protocol Class} undo-tree

The base class for all undo trees.
@end deftp

@deftp {Protocol Class} standard-undo-record

The base class for all undo records.

Client code typically derives subclasses of this class that are
specific to the application.
@end deftp

@deftp {@class{undo-tree} Initarg} :tree

Supplies the undo tree to which the undo record belongs.
@end deftp

@deffn {Generic Function} add-undo undo-record undo-tree

Add an undo record to the undo tree below the current state, and set
the current state to be below the transition represented by the undo
record.
@end deffn

@deffn {Generic Function} flip-undo-record undo-record

This function is called by the undo module whenever the current state
is changed from its current value to that of the parent state
(presumably as a result of a call to undo) or to that of one of its
child states.

Client code is required to supply methods for this function on
client-specific subclasses of undo-record.
@end deffn

@deffn {Generic Function} undo undo-tree &optional (n 1)

Move the current state n steps up the undo tree and call
flip-undo-record on each step.  If the current state is at a level
less than n, a no-more-undo condition is signaled and the current
state is not moved (and no calls to flip-undo-record are made).

As long as no new record are added to the tree, the undo module
remembers which branch it was in before a sequence of calls to undo.
@end deffn

@deffn {Generic Function} redo undo-tree &optional (n 1)

Move the current state n steps down the remembered branch of the undo
tree and call flip-undo-record on each step.  If the remembered
branch is shorter than n, a no-more-undo condition is signaled and
the current state is not moved (and no calls to flip-undo-record are
made).
@end deffn

@node Implementation
@subsubsection Implementation

Application states have no explicit representation, only undo records
do.  The current state is a pointer to an undo record (meaning, the
current state is BELOW the transition represented by the record) or to
the undo tree itself if the current state is the initial state of the
application.

@node How The Buffer Handles Undo
@subsubsection How The Buffer Handles Undo

@deftp {Class} undo-mixin

This is a mixin class that buffer classes can inherit from. It contains
an undo tree, an undo accumulator and a flag specifyng whether or not it
is currently performing undo. The undo tree and undo accumulators are
initially empty.
@end deftp

@deffn {Generic Function} undo-tree undo-mixin

A slot reader.  Returns the undo-tree of the buffer.
@end deffn

Undo is implemented as :before methods on, insert-buffer-object,
insert-buffer-sequence and delete-buffer-range specialized on
undo-mixin.

@deffn {Generic Function} undo-accumulate undo-mixin
A slot accessor.  This list returned by thus function is initially nil
(the empty list).  The :before methods on insert-buffer-object,
insert-buffer-sequence, and delete-buffer-range push undo records on to
this list.
@end deffn

@deffn {Generic Function} performing-undo undo-mixin

A slot accessor.  This slot is initially nil.  The :before methods on
insert-buffer-object, insert-buffer-sequence, and delete-buffer-range
push undo records onto the undo accumulator only if this slot is nil so
that no undo information is added as a result of an undo operation.
@end deffn

Three subclasses `insert-record', `delete-record', and
`compound-record' of undo-record are used.  An insert record stores a
position and some sequence of objects to be inserted, a delete record
stores a position and the length of the sequence to be deleted, and a
compound record stores a list of other undo records.

The :before methods on insert-buffer-object and insert-buffer-sequence
push a record of type delete-record onto the undo accumulator for the
buffer, and the :before method on delete-buffer-range pushes a record of
type insert-record onto the undo accumulator.

@defmac with-undo (get-buffers-exp) &body body

This macro executes the forms of `body', registering changes made to the
list of buffers retrieved by evaluating `get-buffers-exp'. When `body'
has run, for each buffer it will call add-undo with an undo record and
the undo tree of the buffer.  If the changes done by `body' to the
buffer has resulted in only a single undo record, it is passed as is to
add-undo.  If it contains several undo records, a compound undo record
is constructed out of the list and passed to add-undo.  Finally, if the
buffer has no undo records, add-undo is not called at all.
@end defmac

To avoid storing an undo record for each object that is inserted,
the with-undo macro may in some cases just increment the length of
the sequence in the last delete-record.

The method on flip-undo-record specialized on insert-record binds
performing-undo for the buffer to t, inserts the sequence of objects in
the buffer, and calls change-class to convert the insert-record to a
delete-record, giving it a the length of the stored sequence.

The method on flip-undo-record specialized on delete-record binds
performing-undo for the buffer to t, deletes the range from the buffer,
and calls change-class to convert the delete-record to an insert-record,
giving it the sequence at the stored offset in the buffer with the
specified length.

The method on flip-undo-record specialized on compound-record binds
performing-undo for the buffer to t, recursively calls flip-undo-record
on each element of the list of undo records, and finally destructively
reverses the list.

@deftp {Class} drei-undo-record

A subclass of standard-undo-record.
@end deftp

@deftp {@class{drei-undo-record} Initarg} :buffer

The buffer to which the record belongs.
@end deftp

@deftp {Class} simple-undo-record

A subclass of drei-undo-record.
@end deftp

@deftp {@class{simple-undo-record} Initarg} :offset

This initarg is mandatory and supplies the offset that determines the
position at which the undo operation is to be executed.
@end deftp

@deffn {Generic Function} undo-offset undo-record

Return the offset of the undo record.
@end deffn

@deftp {Class} delete-record

A subclass of buffer-undo-record.  Whenever objects are inserted, a
delete-record containing a mark is created and added to the undo
tree.
@end deftp

@deftp {@class{delete-record} Initarg} :length

Supply the length of the sequence of objects to be deleted whenever
flip-undo-record is called on an instance of delete-record.
@end deftp

@deftp {Class} insert-record

A subclass of simple-undo-record.  Whenever objects are deleted, the
sequence of objectgs is stored in an insert record containing a mark.
@end deftp

@deftp {@class{insert-record} Initarg} :objects

Supply the sequence of objects that are to be inserted whenever
flip-undo-record is called on an instance of insert-record.
@end deftp

@deftp {Class} compound-record

A subclass of simple-undo-record.  This record simply contains a list
of other records.
@end deftp

@deftp {@class{compound-record} Initarg} :records

A list of output records.
@end deftp

@node Kill Ring Protocol
@subsection Kill Ring Protocol

During the process of text editing it may become necessary for regions
of text to be manipulated non-sequentially.  The kill ring and its
surrounding protocol offers both a temporary location for data to be
stored, as well as methods for stored data to be accessed.

Conceptually, the kill ring is a stack of bounded depth, so that when
elements are pushed beyond that depth, the oldest element is removed.
All newly added data is attached to a single point at the ``start of
ring position'' or SORP.

This protocol provides two methods which govern how data is to be
attached to the SORP.  The first method moves the current SORP to a new
position, on to which a new object is attached.  The second conserves
the current position and replaces its contents with a sequence
constructed of new and pre-existing SORP objects.  This latter method is
refered to as a ``concatenating push''.

For data retrievial the kill ring class provides a ``yank point'' which
allows focus to be shifted from the SORP to other positions within the
kill ring.  The yank point is limited to two types of motition, one
being a rotation away from the SORP and the other being an immediate
return or ``reset'' to the start position. When the kill ring is
modified, for example by a push, the yank point will be reset to the
start position.

@menu
* Kill Ring Protocol Specification::  
* Kill Ring Implementation::    
@end menu

@node Kill Ring Protocol Specification
@subsubsection Kill Ring Protocol Specification

@deftp {Class} kill-ring

A class for all kill rings.
@end deftp

@deftp {init-arg} :max-size

A limitation placed upon the number of elements held by a kill ring.  Once the maximum size
has been reached, older entries must first be removed before new ones can be added.
@end deftp

@deffn {Generic Function} kill-ring-max-size kill-ring

Returns the value of a kill ring's maximum size.
@end deffn

@deffn {Generic Function} {(setf kill-ring-max-size)} size kill-ring

Alters the maximum size of a kill ring even if it means dropping
elements to do so.
@end deffn

@deffn {Generic Function} kill-ring-length kill-ring

Returns the current length of a kill-ring.  Note this is different than
kill-ring-max-size.
@end deffn

@deffn {Generic Function} kill-ring-standard-push kill-ring vector

Pushes a vector of objects onto a given kill ring creating a new start of ring
position.  This function is much like an everyday lisp push with size considerations.
If the length of the kill ring is greater than its maximum size, ``older'' elements
will be removed from the ring until the maximum size is reached.
@end deffn

@deffn {Generic Function} kill-ring-concatenating-push kill-ring vector

Concatenates the contents of vector onto the end of the contents of
the current top of the kill-ring.  If the kill-ring is empty, a new
entry is pushed.
@end deffn

@deffn {Generic Function} kill-ring-reverse-concatenating-push kill-ring vector

Concatenates the contents of vector onto the front of the current
contents of the top of the kill ring. If the kill ring is empty a new
entry is pushed.
@end deffn

@deffn {Generic Function} rotate-yank-position kill-ring &optional times

Moves the yank point associated with a kill-ring one or times many positions
away from the start of ring position.  If times is greater than the current length
then the cursor will wrap to the start of ring position and continue rotating.
@end deffn

@deffn {Generic Function} reset-yank-position kill-ring

Moves the current position of the yank point associated with a kill ring
back to the start of ring position.
@end deffn

@deffn {Generic Function} kill-ring-yank kill-ring &optional reset

Returns the vector of objects currently pointed to by the cursor.  If
reset is T, then a call to reset-yank-position is called before the
object is yanked.  The default for reset is NIL. If the kill ring is
empty, a condition of type `empty-kill-ring' is signalled.
@end deffn

@node Kill Ring Implementation
@subsubsection Kill Ring Implementation

The kill ring structure is built mainly of two parts: the stack like
ring portion, which is a cursorchain, and the yank point, which is a
left-sticky-flexicursor.  To initialize a kill ring, the :max-size slot
initarg is simply used to set the max size.  The remaining slots
constisting of the cursorchain and the left-sticky-flexicursor are
instantized upon creation of the kill ring.

Stored onto the cursorchain are simple-vectors of objects, mainly
characters from a Drei buffer.  In order to facilitate this, the kill
ring implementation borrows heavily from the flexichain library of
functions. The following functions lie outside the kill ring and
flexichain protocols, but are pertinent to the kill ring implementation.

@deffn {accessor} kill-ring-chain kill-ring

A slot accessor provided by the Drei implemention of the kill ring
class, which returns the cursorchain associated with kill-ring.
@end deffn

@deffn {accessor} kill-ring-cursor kill-ring

A slot accessor provided by the Drei implemention of the kill ring
class, which returns the flexicursor assocated with kill-ring.
@end deffn

@node Defining Drei Commands
@section Defining Drei Commands

Drei commands are standard CLIM commands that are stored in standard
CLIM command tables. Drei uses a number of distinct command tables, some
of which are merely used to group commands by category, and some whose
contents may only be applicable under specific circumstances. When the
contents of a command table is applicable, that command table is said to
be active. Some syntaxes may define specific command tables that will
only be active for buffers using that syntax. Commands in such tables
are called syntax-specific commands.

@menu
* Drei Command Tables::         
* Numeric Argument In Drei::    
* Examples Of Defining Drei Commands::  
* Drei's Syntax Command Table Protocol::  
@end menu

@node Drei Command Tables
@subsection Drei Command Tables

Here is a list of the command tables that are always active, along with
a note describing what they are used for:

@deftp {Command Table} comment-table
Commands for dealing with comments in, for example, source code. For
syntaxes that do not have the concept of a comment, many of the commands
of this table will not do anything.
@end deftp
@deftp {Command Table} deletion-table
Commands that destructively modify buffer contents.
@end deftp
@deftp {Command Table} editing-table
Commands that transform the buffer contents somehow (such as transposing
two words).
@end deftp
@deftp {Command Table} fill-table
Commands that fill (wrap) text.
@end deftp
@deftp {Command Table} case-table
Commands that modify the case of characters.
@end deftp
@deftp {Command Table} indent-table
Commands that indent text based on the current syntax.
@end deftp
@deftp {Command Table} marking-table
Commands that deal with managing the mark or nondestructively copying
buffer contents.
@end deftp
@deftp {Command Table} movement-table
Commands that move point.
@end deftp
@deftp {Command Table} search-table
Commands that can search the buffer.
@end deftp
@deftp {Command Table} info-table
Commands that display information about the state of the buffer.
@end deftp
@deftp {Command Table} self-insert-table
Commands that insert the gesture used to invoke them into the
buffer. You probably won't need to add commands to this table.
@end deftp
@deftp {Command Table} editor-table
A command table that inherits from the previously mentioned tables (plus
some more). This command table is the ``basic'' table for accessing Drei
commands, and is a good place to put your own user-defined commands if
they do not fit in another table.
@end deftp

There are also two conditionally-active command tables:

@deftp {Command Table} exclusive-gadget-table
This command table is only active in the gadget version of Drei.
@end deftp
@deftp {Command Table} exclusive-input-editor-table
This command table is only active when Drei is used as an input-editor.
@end deftp

When you define keybindings for your commands, you should put the
keybindings in the same command table as the command itself.

@node Numeric Argument In Drei
@subsection Numeric Argument In Drei
@cindex numeric argument

The numeric argument state is currently not directly accessible from
within commands. However, Drei uses ESA's numeric argument processing
code, Drei commands can thus be provided with numeric arguments in the
same way as ESA commands can. When using @cl{set-key} to setup
keybindings, provide the value of @cl{*numeric-argument-marker*} as an
argument to have the command processing code automatically insert the
value of the numeric argument whenever the keybinding is invoked. You
can also use @cl{*numeric-argument-p*} to have a boolean value, stating
whether or not a numeric argument has been provided by the user,
inserted. Note that you must write your commands to accept arguments
before you can do this (@pxref{Examples Of Defining Drei Commands}).

@node Examples Of Defining Drei Commands
@subsection Examples Of Defining Drei Commands
@cindex Drei command defining
@cindex defining Drei commands

A common text editing task is to repeat the word at point, but for some
reason, Drei does not come with a command to do this, so we need to
write our own. Fortunately, Drei is extensible software. We're going to
put our command in the @package{DREI-COMMANDS} package, though,
strictly, that is an internal package. We're going to create a standard
CLIM command named @cl{com-repeat-word} in the command table
@cl{editing-table}. We'll clone the current point, move it a word
backward, and insert into the buffer the sequence delimited by point and
our moved mark. Our command takes no arguments.

@lisp
(define-command (com-repeat-word :name t
                                 :command-table editing-table)
    ()
  (let ((mark (clone-mark *current-point*)))
    (backward-word mark *current-syntax* 1)
    (insert-sequence mark (region-to-sequence mark *current-point*))))
@end lisp

For @cl{*current-point*} and @cl{*current-syntax*}, see @ref{Special
Variables}.

This command facilitates the single repeat of a word, but that's
it. This is not very useful - instead, we would like a command that
could repeat a word an arbitrary (user-supplied) number of times. The
primary way for a CLIM command to ask for user-supplied values is to use
command arguments. We define a new command that takes an integer
argument specifying the number of times to repeat the word at point.

@lisp
(define-command (com-repeat-word :name t
                                 :command-table editing-table)
    ((count 'integer :prompt "Number of repeats"))
  (let ((mark (clone-mark *current-point*)))
    (backward-word mark *current-syntax* 1)
    (let ((word (region-to-sequence mark *current-point*)))
      (dotimes (i count)
        (insert-sequence mark word)))))
@end lisp

Great - our command is now pretty full-featured. But with an editing
operation as common as this, we really want it to be quickly accessible
via some intuitive keystroke. We choose @kbd{M-C-r}. Also, it'd be nice
if, instead of interactively quering us for commands, the command would
just use the value of the numeric argument as the number of times to
repeat. There's no way to do this with a named command (ie. when you run
the command with @kbd{M-x}), but it's quite easy to do in a
keybinding. We use the ESA @cl{set-key} function:

@lisp
(set-key `(com-repeat-word ,*numeric-argument-marker*)
         'editing-table
         '((#\r :control :meta)))
@end lisp

Now, pressing @kbd{M-C-r} will result in the @cl{com-repeat-word}
command being run with the first argument substituted for the value of
the numeric argument. Since the numeric argument will be 1 if nothing
else has been specified by the user, we are guaranteed that the first
argument is always an integer, and we are guaranteed that the
@var{count} argument will have a sensible default, even if the user does
not explicitly provide a numeric argument.

@node Drei's Syntax Command Table Protocol
@subsection Drei's Syntax Command Table Protocol
@cindex syntax command table

In order to provide conditionally active command tables, Drei defines
the @class{syntax-command-table} class. While this class is meant to
facilitate the addition of commands to syntaxes when they are run in a
specific context (for example, a large editor application adding a Show
Macroexpansion command to Lisp syntax), their modus operandi is general
enough to be used for all conditional activity of command tables.
