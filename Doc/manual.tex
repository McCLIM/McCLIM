\documentclass{book}

\usepackage[latin1]{inputenc}
\usepackage{color}
\usepackage{epsfig}
\usepackage{alltt}

\setlength{\parskip}{0.3cm}
\setlength{\parindent}{0cm}

\def\inputfig#1{\input #1}

\newenvironment{itemize0}{
\begin{itemize}
\setlength{\parskip}{0cm}%
}
{\end{itemize}}

\newenvironment{enumerate0}{
\begin{enumerate}
\setlength{\parskip}{0cm}%
}
{\end{enumerate}}

\input spec-macros

\newcommand{\gloss}[1]{\textsl{\textcolor{red}{#1}}}
\newcommand{\glossentry}[1]{\paragraph{#1}}
\newcommand{\class}[1]{\texttt{#1}}
\newcommand{\genfun}[1]{\texttt{#1}}
\newcommand{\macro}[1]{\texttt{#1}}
\newcommand{\gadget}[1]{\texttt{#1}}
\newcommand{\pane}[1]{\texttt{#1}}
\newcommand{\initarg}[1]{\texttt{#1}}
\newcommand{\methcomp}[1]{\texttt{#1}}
\newcommand{\slot}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\longref}[1]{(See \ref{#1})}
\newcommand{\var}[1]{\textit{#1}}

\title{McCLIM 0.01 user's manual}
\author{Robert Strandh \\ strandh@labri.fr}

\begin{document}
\maketitle

{\setlength{\parskip}{0cm}
\tableofcontents}

\chapter{Introduction}

CLIM is a large layered software system that allows the user to
customize it at each level.  The most simple ways of using CLIM is to
directly use its top layer, which contains application frames, panes,
and gadgets, very similar to those of traditional windowing system
toolkits such as GTK, Tk, and Motif.

But there is much more to using CLIM.  In CLIM, the upper layer with
panes and gadgets is written on top of a basic layer containing more
basic functionality in the form of sheets.  Objects in the upper layer
are typically instances of classed derived from those of the lower
layer.  Thus, nothing prevents a user from adding new gadgets and
panes by writing code that uses the sheet layer. 

Finally, since CLIM is written in Common Lisp, essentially all parts
of it can be modified, replaced, or extended.  

For that reason, a user's manual for CLIM must contain not only a
description of the protocols of the upper layer, but also of all
protocols, classes, functions, macros, etc. that are part of the
specification. 

This manual documents McCLIM 0.01 which is a partial implementation of
the CLIM 2.0 specification.

\part{Getting Started}

\chapter{Panes and Gadgets}

A CLIM application is made up of a hierarchy of \gloss{panes} and
\gloss{gadgets} (gadgets are special kinds of panes).  Theses elements
correspond to what other toolkits may call \emph{widgets}.
Frequently used CLIM gadgets are \gadget{button}s, \gadget{slider}s,
etc, and typical panes are the layout panes such as \pane{hbox},
\pane{vbox}, \pane{hrack}, etc.

\chapter{Defining Appliction Frames}

Each CLIM application is defined by an \gloss{application frame}.  An
application frame is an instance of the class
\class{application-frame}.  As a CLIM user, you typically define a
class that inherits from the class \class{application-frame}, and
that contains additional slots needed by your application.  It is
considered good style to keep all your application-specific data in
slots in the application frame (rather than, say, in global
variables), and to define your application-specific application frame
in its own package.  

The usual way to define an application frame is to use the macro
\macro{define-application-frame}.  This macro works much like
\macro{defclass}, but also allows you to specify the hierarchy of
\gloss{panes} and \gloss{gadgets} to use. 

\part{Reference Manual}

\chapter{Concepts}

\section{Coordinate systems}

CLIM uses a number of different coordinate systems and transformations
to transform coordinates between them.

The coordinate system used for the arguments of drawing functions is
called the \gloss{user coordinate system}, and coordinate values
expressed in the user coordinate system are known as \gloss{user
coordinates}.

User coordinates are translated to \gloss{sheet coordinates} by means
of the \gloss{user transformation} also called the \gloss{medium
transformation}.  This transformation is stored in the \gloss{medium}
used for drawing.  The medium transformation can be composed
temporarily with a transformation given as an explicit argument to a
drawing function.  In that case, the user transformation is
temporarily modified for the duration of the drawing. 

Before drawing can occur, coordinates in the sheet coordinate system
must be transformed to \gloss{native coordinates}, which are
coordinates of the coordinate system of the native windowing system.
The transformation responsible for computing native coordinates from
sheet coordinates is called the \gloss{native transformation}.  

The composition of the user transformation and the native
transformation is called the \gloss{device transformation}.  It allows
drawing functions to transform coordinates only once before obtaining
native coordinates. 

Sometimes, it is useful to express coordinates of a sheet in the
coordinate of its parent.  The transformation responsible for that is
called the \gloss{sheet transformation}.  

\section{Arguments to drawing functions}

Drawing functions are typically called with a sheet as an argument.

A sheet often, but not always, corresponds to a window in the
underlying windowing system.  

\chapter{Windowing system drawing functions}

A typical windowing system provides a hierarchy of rectangular areas
called windows.  When a drawing functions is called to draw an object
(such as a line or a circle) in a window of such a hierarchy, the
arguments to the drawing function will include at least the window and
a number of coordinates relative to (usually) the upper left corner of
the window.

To translate such a request to the actual altering of pixel values in
the video memory, the windowing system must translate the coordinates
given as argument to the drawing functions into coordinates relative
to the upper left corner of the entire screen.  This is done by a
composition of translation transformations applied to the initial
coordinates.  These transformations correspond to the position of each
window in the coordinate system of its parent. 

Thus a window in such a system is really just some values indicating
its height, its width, and its position in the coordinate system of
its parent, and of course information about background and foreground
colors and such.

\chapter{CLIM drawing functions}

CLIM generalizes the concept of a hierarchy of window in a windowing
system in several different ways.  A window in a windowing system
generalizes to a \gloss{sheet} in CLIM.  

CLIM sheets don't have to be rectangular the way windows in most
windowing systems have to be.  Thus, the width and the height of a
window in a windowing system generalizes to a \gloss{region} in CLIM.
A CLIM region is simply a set of mathematical points in a plane.

Even rectangular regions in CLIM are generalizations of the
width+height concept of windows in most windowing systems.  While the
upper left corner of a window in a typical windowing system has
coordinates (0,0), that is not necessarily the case of a CLIM region.
CLIM uses that generalization to implement various ways of scrolling
the contents of a sheet.  To see that, imagine just a slight
generalization of the width+height concept of a windowing system into
a rectangular region with x+y+width+height.  Don't confuse the x and y
here with the position of a window within its parent, they are
different.  Instead, imagine that the rectangular region is a hole
into the (infinite) drawing plane defined by all possible coordinates
that can be given to drawing functions.  

CLIM sheets also generalize windows in that a window typically has
pixels with integer-value coordinates.  CLIM sheets, on the other
hand, have infinte resolution.  Drawing functions accept non-integer
coordinate values which are only translated into integers just before
the physical rendering on the screen.

The x and y positions of a window in the coordinate system of its
parent window in a typical windowing system is a translation
transformation that takes coordinates in a window and transform them
into coordinates in the parent window.  CLIM generalizes this concepts
to arbitrary affine transformations (combinations of translations,
rotations, and scalings).  This generalization makes it possible for
points in a sheet to be not only translated compared to the parent
sheet, but also rotated and scaled (including negative scaling, giving
mirror images).  A typical use for scaling would be for a sheet to be
a zoomed version of its parent, or for a sheet to have its
y-coordinate go the opposite direction from that of its parent. 

When the shapes of, and relationship between sheets are as simple as
those of a typical windowing system, each sheet typically has an
associated window in the underlying windowing system.  In that case,
drawing on a sheet translates in a relativly straightforward way into
drawing on the corresponding window.  CLIM sheets that have associated
windows in the underlying windowing system are called \gloss{mirrored
sheets} and the system-dependent window object is called the
\gloss{mirror}.  When shapes and relationships are more complicated,
CLIM uses its own transformations to transform coordinates from a
sheet to its parent and to its grandparent, etc., until a
\gloss{mirrored sheet} is found.  To the user of CLIM, the net effect
is to have a windowing system with more general shapes of, and
relationships between windows.

\section{Computing the native transformation}

CLIM maintains, for each sheet that supports output, a \gloss{native
transformation}.  The native transformation is used by drawing
functions to transform coordinates to \gloss{native coordinates},
i.e., those required by the windowing system.  In this section, we
examine how that computation is made.

To get an idea of the complexity involved, let us imagine a mirrored
sheet (one that actually \emph{has} a mirror) $s$, which has a nontrivial
native transformation, for instance one that is used to draw
PostScript commands.  The coordinate system of such a sheet has an
$x$ axis that grows to the right, and a $y$ axis that grows upwards. 
Let us further imagine that the region of $s$ is some kind of oval
shape as shown in figure \ref{fignative}.

\begin{figure}
\begin{center}
\inputfig{native.pstex_t}
\end{center}
\caption{\label{fignative} A sheet with a nontrivial transformation}
\end{figure}

We have to assume that the origin of the X window (let us call it $w$)
is known with respect to the region of $s$.  Since we can control
that, let us make the very reasonable assumption that $w$ is the
smallest window that covers the region so that the dot in figure
\ref{fignative} is the origin of $w$.  Let us say that point is
$(10,40)$ in the coordinate system of $s$.

In the coordinate system of $s$, the region is $30$ units tall and
$20$ units wide.  But let us say that there is a discrepancy between
the units of $s$ and those of $w$ such that in reality $w$ is only
$15$ pixels tall and $10$ pixels wide.  This can happen as a result of
zooming, or simply that $s$ was designed with a different scaling in
mind.  The native transformation of $s$ must therefore transform the
point $(0,0$ to $(-5,20)$ and $(10,40)$ to $(0,0)$.  We now have to
determine how this transformation can be computed from other, existing
transformations.  Since we are working with X11, we know that the
coordinate system of $w$ is just a translation of that of its parent
window (let us call it $wp$.  In figure \ref{fignative}, the origin of
the coordinate system of $wp$ is marked with a $+$.  

Let us say that the origin of $w$ in the coordinate system of $wp$ is
$(x_w,y_w$.  That is the same as the \emph{window position} of $w$
with respect to its parent, as maintained by X11.

Now, the parent of $s$ (let us call it $sp$) is a sheet which
(according to the CLIM specification) must parallel $wp$ in that
drawings on $sp$ must end up on $wp$.  If $sp$ has a direct mirror, it
must be $wp$.  Otherwise $wp$ must be the direct mirror of the first
ancestor of $sp$ having a direct mirror.  Now, $sp$ has \emph{its}
native transformation, making it possible for any drawing function
applied to $sp$ to appear correctly on $wp$.  Let us call that
transformation $NT(sp$).  Assume for a moment that $w$ did not exist.
Drawings on $s$ would have to end up on $wp$.  Obtaining that is
fairly easy.  Just compose the transformation of $s$ (which gives
coordinates in $sp$ from coordinates in $s$) with $NT(sp$).  Let us
call that transformation $NTP(s)$. Now, let's go back to $w$.  To get
coordinates in $w$ from coordinates in $s$, you must then take the
coordinates of $s$, transform them by $NTP(S)$ and then subtract $(x_w,y_w)$.
Therefore, you can compute $NT(s)$ as the composition of $NTP(s)$ and the
translation transformation $(-x_w,-y_w)$.

Now we have an algorithm for computing native transformations:

\begin{enumerate0}

\item The native transformation of the graft is decided by the frame
manager.

\item The native transformation of any sheet with a mirror other than
the graft is the composition of its transformation, the native
transformation of its parent, and the negation of the transformation
defined as the position of its mirror with respect to the parent of
the mirror.

\item The native transformation of any sheet without a mirror is the
composition of its transformation and the native transformation of its
parent.
\end{enumerate0}


\chapter{Sheet hierarchy}

CLIM sheets are organized into a hierarchy.  Each sheet has a sheet
transformation and a sheet region.  The sheet tranformation determines
how coordinates in the sheet's own coordinate system get translated
into coordinates in the coordinate system of its parent.  The sheet
region determines the \gloss{potentially visible area} of the
otherwise infinite drawing plane of the sheet.

Panes are subclasses of sheets.  Some panes are \gloss{layout panes}
that determine the size and position its children according to rules
specific to each particular type of layout pane.  Examples of layout
panes are vertical and horizontal boxes, tables etc.

\section{Layout protocol}

There is a set of fundamental rules of CLIM dividing responsibility
between a parent pane and a child pane, with respect to the size and
position of the region of the child and the \gloss{sheet
transformation} of the child.  This set of rules is called the
\gloss{layout protocol}.

The layout protocol is executed in two phases.  The first phase is
called the \gloss{space compostion} phase, and the second phase is
called the \gloss{space allocation} phase.

\subsection{Space composition}

The space composition is accomplished by the generic function
\genfun{compose-space}.  When applied to a pane,
\genfun{compose-space} returns an object of type
\gloss{space-requirement} indicating the needs of the pane in terms of
preferred size, minimum size and maximum size.  The phase starts when
compose-space is applied to the top-level pane of the application
frame.  That pane in turn may ask its children for their space
requirements, and so on until the leaves are reached.  When the
top-level pane has computed its space requirments, it asks the system
for that much space.  A conforming window manager should respect the
request (space wanted, min space, max space) and allocate a top-level
window of an acceptable size.  The space given by the system must then
be distributed among the panes in the hierarchy
\longref{space-allocation}.

Each type of pane is responsible for a different method on
\genfun{compose-space}.  Leaf panes such as \gloss{labelled gadgets}
may compute space requirements based on the size and the text-style of
the label.  Other panes such as the vbox layout pane compute the space
as a combination of the space requirements of their children.  The
result of such a query (in the form of a space-requirement object) is
stored in the pane for later use, and is only changed as a result of a
call to \genfun{note-space-requirement-changed}.

Most \gloss{composite panes} can be given explicit values for the
values of \initarg{:width}, \initarg{:min-width},
\initarg{:max-width}, \initarg{:height}, \initarg{:min-height}, and
\initarg{:max-height} options.  If such arguments are not given
(effectively making these values nil), a general method is used, such
as computing from children or, for leaf panes with no such reasonable
default rule, a fixed value is given.  If such arguments are given,
their values are used instead.  Notice that one of \initarg{:height}
and \initarg{:width} might be given, applying the rule only in one of
the dimensions.

Subsequent calls to \genfun{compose-space} with the same arguments are
assumed to return the same space-requirement object, unless a call to
note-space-requirement-changed has been called in between.

\subsection{Space allocation}
\label{space-allocation}

When \genfun{allocate-space} is called on a pane \var{P}, it must
compare the space-requirement of the children of \var{P} to the
available space, in order to distribute it in the most preferable way.
In order to avoid a second recursive invokation of
\genfun{compose-space} at this point, we store the result of the
previous call to \genfun{compose-space} in each pane.

To handle this situtation and also explicitly given size options, we
use an \methcomp{:around} method on \genfun{compose-space}.  The
\methcomp{:around} method will call the primary method only if necessary (i.e.,
\code{(eq (slot-value pane 'space-requirement) nil)}), and store the
result of the call to the primary method in the
\slot{space-requirement} slot. 

We then compute the space requirement of the pane as follows:

\begin{alltt}
     (setf (space-requirement-width ...)
           (or explicit-width (space-requirement-width request))
           ...
           (space-requirement-max-width ...)
           (or explicit-max-width
               explicit-width
               (space-requirement-max-width request))
           ...)
\end{alltt}

When the call to the primary method is not necessary we simply
return the stored value.

The \pane{spacer-pane} is an exception to the rule indicated above. 
The explicit size you can give for this pane should represent the margin
size.  So its primary method should only call compose on the child.
And the around method will compute the explicit sizes for it from
the space requirement of the child and for the values given for the
surrounding space. 



\section{Change-space Notification Protocol}

The purpose of the change-space notification protocol is to force a
recalculation of the space occupied by potentially each pane in the
\gloss{pane hierarchy}.  The protocol is triggerred by a call to
\genfun{note-space-requirement-changed} on a pane \var{P}. In McCLIM,
we must therefore invalidate the stored space-requirement value and
re-invoke \genfun{compose-space} on \var{P}.  Finally, the
\gloss{parent} of \var{P} must be notified recursively.  

This process would be repeated for all the panes on a path from
\var{P} to the top-level pane, if it weren't for the fact that some
panes compute their space requirements independently of those of their
children.  Thus, we stop calling
\genfun{note-space-requirement-changed} in the following cases:

\begin{itemize}
\item when \var{P} is a \pane{restraining-pane},
\item when \var{P} is a \pane{top-level-sheet-pane}, or
\item when \var{P} has been given explicit values for \initarg{:width}
  and \initarg{:height}
\end{itemize}

In either of those cases, \genfun{allocate-space} is called. 

\part{Extensions}

\chapter{Drawing Two-Dimensional Images}

\section{Image Architecture}

\subsection{Images}

Images are all rectangular arrangements of pixels.  The type of a
pixel depends on the exact type of the image.  In addition, a pixel 
has a color which also depends on the exact type of the image.  You
can think of the color as an interpretation of the pixel value by the
type of image. 

Te coordinate system of an image has (0,0) in its upper-left corner.
The x coordinate grows to the right and the y coordinate downwards.  

\defprotoclass{image}

This class is the base class for all images.  

\defgeneric {image-width} {image}
\defgeneric {image-height} {image}

This function returns the width and the height of the image
respectively.

\defgeneric {image-pixels} {image}

This function returns a two-dimensional array of pixels, whose element
type depends on the exact subtype of the image. 

\defgeneric {image-pixel} {image x y}

This function returns the pixel at the coordinate indicated by the
values of x and y.  The type of the return value depends on the exact
image type.

\defgeneric {(setf image-pixel)} {x y pixel image}

Set the value of the pixel at the coordinate indicated by the values
of x and y.  The exact type acceptable for the pixel argument depends
on the exact subtype of the image.  If x or y are not within the
values of the width and height of the image, an error is signaled. 

\defgeneric {image-color} {image x y}

This function returns the color value of the pixel indicated by the
values of x and y.  The exact type of the return value depends on the
specific subtype of the image. 

\defgeneric {(setf image-color)} {x y color image}

Set the color value of the pixel at the coordinate indicated by the
values of x and y.  The exact type acceptable for the color argument
depends on the exact subtype of the image.  In addition, the exact
color given to the pixel may be an approximation of the value of the
color argument.  For instance, if the image is a gray-level image,
then the color given will correspond to the intensity value of the
color argument.  If x or y are not within the values of the width and
height of the image, an error is signaled.

\defprotoclass{spectral-image}

This class is a subclass of the image class.  It is the root of a
subhiearchy for manipulating images represented in various spectral
formats, other than RGB.  [This subhierarchy will be elaborated later
in the context of the color model of Strandh and Braquelaire].

\defprotoclass{rgb-image}

This class is a subclass of the image class.  It is the root of a
subhierarchy for manipulating images whose pixel colors are
represented as RGB coordinates.  The function image-color always
returns a value of type (unsigned-byte 24) for images of this type,
representing three different intensity values of 0-255. 

\defprotoclass{truecolor-image}

This class is a subclass of the rgb-image class.  Images of this class
have pixel values of type (unsigned-byte 24).  The pixel values
directly represent RGB values.

\defprotoclass{colormap-image}

This class is a subclass of the rgb-image class.  Images of this class
have pixel values that don't directly indicate the color of the pixel.
The translation between pixel value and color may be implicit (as is
the case of gray-level images) or explicit with a colormap stored in
the image object.

\defprotoclass{gray-level-image}

This class is a subclass of the colormap-image class.  Images of this
type have pixel values that implicitely represent a gray-level.  The
function pixel-color always returns an RGB value that corresponds to
the identical intensities for red, green, and blue, according to the
pixel value. 

\defgeneric {gray-image-max-levels} {gray-level-image}

This function returns the maximum number of levels of gray that can be
represented by the image.  The value returned by this function minus
one would yield a color value of 255,255,55 if it were the value of a
pixel.

\defgeneric {gray-image-max-level} {gray-level-image}

This function returns the maximum level currently present in the
image.  This function may be very costly to compute, as it might have
to scan the entire image. 

\defgeneric {gray-image-min-level} {gray-level-image}

This function returns the minimum level currently present in the
image.  This function may be very costly to compute, as it might have
to scan the entire image. 

\defclass {256-gray-level-image}

This class is a subclass of the gray-level-image class.  Images of
this type have pixels represented as 8-bit unsigned pixels.  The
function image-pixel always returns a value of type (unsigned-byte 8)
for images of this type.  The function gray-image-max-levels returns
256 for all instances of this class.

\defclass {binary-image}

This class is a subclass of the gray-level-image class.  Images of
this type have pixel values of type bit.  The function image-pixel
returns values of type bit when applied to an image of this type.  The
function pixel-color returns 0,0,0 for zero-valued bits and
255,255,255 for one-valued bits.

\subsection{Utility Functions}

\defgeneric {rotate-image} {image angle \key (antialias t)}
\defgeneric  {flip-image} {image ...}
\defgeneric  {translate-image} {image ...}
\defgeneric  {scale-image} {image ...}
 ...

\section{Reading Image Files}

\defgeneric {read-image} {source \key type width height}

Read an image from the source.  The source can be a pathname
designator (a string or a path), or a stream.  The caller can supply a
value for type, width, and height for sources that don't indicate
these values.  A value of nil for type means recognize the type automatically.
Other values for type are :truecolor (an array of 3-byte color values)
:256-gray-level (an array of 1-byte gray-level values) :binary (an
array of bits). 

\defgeneric {write-image} {image destination \key (type :pnm) (quality 1)}

Write the image to the destination.  The destination can be a pathname
designator (a string or a path), or a stream.  Valid values of type
are :pnm (pbm, pgm, or ppm according to the type of image), :png,
:jpeg, (more...).  The quality argument is a value from 0 to 1 and
indicates desired image quality (for formats with lossy compression). 

\chapter{File Selector Gadget}

\part{Auxiliary Material}

\chapter{Glossary}

\glossentry{Mirror}

A device window such as an X11 window that parallels a \gloss{sheet}
in the CLIM \gloss{sheet hierarchy}.  A \gloss{sheet} having such a
mirror is called a \gloss{mirrored sheet}.  When \gloss{drawing
functions} are called on a \gloss{mirrored sheet}, they are forwarded
to the host windowing system as drawing commands on the
\gloss{mirror}.

CLIM \gloss{sheet}s that are not mirrored must be \gloss{descendents}
(direct or indirect) of a \gloss{mirrored sheet}, which will then be
the \gloss{sheet} that receives the drawing commands. 

\glossentry{Mirrored sheet}

A \gloss{sheet} in the CLIM \gloss{sheet hiearchy} that has a direct
parallel (called the \gloss{mirror}) in the host windowing system. 

\glossentry{Potentially visible area}

A bounded area of an otherwise infinte drawing plane that is visible
unless ...


\glossentry{Sheet coordinates}

The coordinate system of coordinates obtained by application of the
\gloss{user transformation}.  

\glossentry{Sheet region}

The \gloss{region} of a sheet determines the visible part of the
drawing plane.  The dimensions of the sheet region are given in
\gloss{sheet coordinates}.  The location of the visible part of a
sheet within its \gloss{parent sheet} is determined by a combination
of the \gloss{sheet transformation} and the position of the sheet
region.

For instance, assuming that the sheet region is a rectangle with its
upper-left corner at (2, 1) and that the sheet transformation is a
simple translation (3, 2).  Then the origin of the \gloss{sheet
coordinate system} is at the point (3, 2) within the \gloss{sheet
coordinate system} of its \gloss{parent sheet}.  The origin of its the
coordinate system is not visible, however, because the visible region
has its upper-left corner at (2, 1) in the \gloss{sheet coordinate
system}.  Thus, the visible part will be a rectangle whose upper-left
corner is at (5, 3) in the \gloss{sheet coordinate system} of the
\gloss{parent sheet}.

Panes and gadgets alter the region and \gloss{sheet transformation} of
the underlying sheets (panes and gadgets are special kinds of sheets)
to obtain effects such as scrolling, zooming, coordinate system
transformations, etc.

\glossentry{Sheet transformation}

The transformation used to transform \gloss{sheet coordinates} of a
sheet to \gloss{sheet coordinates} of its \gloss{parent sheet}.  The
sheet transformation determine the position, shape, etc. of a sheet
within the coordinate system of its parent.

Panes and gadgets alter the transformation and \gloss{sheet region} of
the underlying sheets (panes and gadgets are special kinds of sheets)
to obtain effects such as scrolling, zooming, coordinate system
transformations, etc.

\glossentry{User Clipping region }

A \gloss{clipping region} used to limit the effect of \gloss{drawing
functions}.  The user \gloss{clipping region} is stored in the
\gloss{medium}.  It can be altered either by updating the
\gloss{medium}, or by passing a value for the :clipping-region
\gloss{drawing option} to a \gloss{drawing function}.

\glossentry{User Coordinates}

The coordinate system of coordinates passed to the \gloss{drawing
functions}.

\glossentry{User Transformation}

A transformation used to transform \gloss{user coordinates} into
\gloss{sheet coordinates}.  The user transformation is stored in the
\gloss{medium}.  It can be altered either by updating the
\gloss{medium}, or by passing a value for the :transformation
\gloss{drawing option} to a \gloss{drawing function}.


\glossentry{Visible area}

\chapter{Development History}

Mike McDonald started developing McCLIM in 1998.  His initial
objective was to be able to run the famous ``address book'' demo, and
to distribute the first version when this demo ran.  With this in
mind, he work ``horizontally'', i.e., writing enough of the code for
many of the chapters of the specification to be able to run the
address book example.  In particular, Mike wrote the code for chapters
15 (Extended Stream Output), 16 (Output Recording), and 28
(Application Frames), as well as the code for interactor panes.  At
the end of 1999, Mike got too busy with other projects, and nothing
really moved.

Also in 1998, Gilbert Baumann started working ``vertically'', writing
a mostly-complete implementation of the chapters 3 (Regions) and 5
(Affine Transformations).  At the end of 1999, he realized that he was
not going to be able to finish the project by himself.  He therfore
posted his code to the free-CLIM mailing list.  Gilbert's code was
distributed according to the GNU Lesser General Public Licence (LGPL).

Robert Strandh picked up the project in 2000, starting from Gilbert's
code and writing large parts of chapters 7 (Properties of Sheets) and
8 (Sheet Protocols) as well as parts of chapters 9 (Ports, Grafts, and
Mirrored Sheets), 10 (Drawing Options), 11 (Text Styles), 12
(Graphics), and 13 (Drawing in Color).

Early 2000, Robert got in touch with Mike and eventually convinced him
to distribute his code, also according to the LGPL.  This was a major
turning point for the project, as the code base was now sufficiently
large that a number of small demos were actually running.  Robert
then spent a few months merging his code into that produced by Mike.  

Arthur Lemmens wrote the initial version of the code for the gadgets
in june of 2000. 

Bordeaux students Iban Hatchondo and Julien Boninfante were hired by
Robert for a 3-month summer project during the summer of 2000.  Their
objective was to get most of the pane protocols written (in particular
space composition and space allocation) as well as some of the gadgets
not already written by Arthur, in particular push buttons.  The
calculator demo was written to show the capabilities of their code.

In July of 2000, Robert invited Gilbert to the LSM-2000 metting in
Bordeaux (libre software meeting).  This meeting is a gathering of
developers of free software with the purpose of discussing strategy,
planning future projects, starting new ones, and working on existing
ones.  The main result of this meeting was that Gilbert managed to
merge his code for regions and transformations into the main code base
written by Mike, Robert, Iban, and Julien.  This was also a major step
towards a final system.  We now had one common code base, with a
near-complete implementation of regions, transformations, sheet
protocols, ports, grafts, graphics, mediums, panes, and gadgets. 

Meanwhile, Mike was again able to work on the project, and during 2000
added much of the missing code for handling text interaction and
scrolling.  In particular, output recording could now be used to
redisplay the contents of an interactor pane.  Mike and Robert also
worked together to make sure the manipulation of sheet transformations
and sheet regions as part of scrolling and space-allocation respected
the specification. 

Robert had initially planned for Iban and Julien to work on McCLIM for
their fifth-year student project starting late 2000 and continuing
until end of march 2001.  For reasons beyond his control, however, he
was forced to suggest a different project.  Thus, Iban and Julien,
together with two other students, were assigned to work on Gsharp, an
interactive score editor.  Gsharp was the original reason for Robert
to start working on CLIM as he needed a toolkit for writing a
graphical user interface for Ghsarp.  The lack of a freely-available
version of a widely-accepted toolkit such as CLIM made him decide to
give it a shot.  Robert's idea was to define the student project so
that a maximum of code could be written as part of McCLIM.  The result
was a complete rewrite of the space-allocation and space-composition
protocols, and many minor code snippets.

As part of the Gsharp project, Robert wrote the code for menu bars and
for a large part of chapter 27 (Command Processing).  

Julien was hired for six months (April to September of 2001) by Robert
to make major progress on McCLIM.  Julien's first task was to create a
large demo that showed many of the existing features of McCLIM (a
``killer app'').  It was decided to use Gsharp since Julien was already
familiar with the application and since it was a sufficiently
complcated application that most of the features would be tested.  An
additional advantage of a large application was to serve as a ``smoke
test'' to run whenever substantial modifications to the code base had
been made.  As part of the Gsharp project, Julien first worked on
adding the possibility of using images as button labels.  

Early 2001, Robert had already written the beginning of a library for
manipulating 2-dimensional images as part of McCLIM.  A group of four
fourth-year students (Gregory Bossard, Michel Cabot, Cyrille Dindart,
Lionel Vergé) at the university of Bordeaux was assigned the task of
writing efficient code for displaying such images subject to arbitrary
affine transformations.  This code would be the base for drawing all
kinds of images such as icons and button labels, but also for an
application for manipulating document images.  The project lasted from
January to May of 2001.

Another group of four fourth-year students (Loïc Lacomme, Nicolas
Louis, Arnaud Rouanet, Lionel Salabartan) at the university of
Bordeaux was assigned the task of writing a file-selector gadget
presented as a tree of directories and files, and with the ability to
open and close directories, to select files, etc.  The project lasted
from January to May of 2001.

One student in particular, Arnaud Rouanet started becoming interested
in the rest of CLIM as well.  During early 2001, he fixed several bugs
and also added new code, in particular in the code for regions,
graphics, and clx-mediums.

Arnaud and Lionel were hired by Robert for the summer of 2001 to
work on ??? [hasn't been decided yet as of this writing].

Rôle of Arthur Lemmens, and others?

\end{document}
